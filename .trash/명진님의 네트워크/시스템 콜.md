### 출처
* https://sincerity.page/categories/School/First_2022/Operating_System_1/#cpu-virtualization (cpu 가상화)
* https://pinelover.tistory.com/153 (시분할 시스템)
* https://0x200.tistory.com/entry/4-Interrupt-%EC%99%80-Exception-2 (인터럽트)
* https://www.javatpoint.com/trap-vs-interrupt-in-operating-system (인터럽트와 트랩)
* https://stackoverflow.com/questions/33654579/in-an-operating-system-what-is-the-difference-between-a-system-call-and-an-inte (시스템콜 인터럽트 필수?)
* https://www.quora.com/Is-every-system-call-a-software-interrupt (시스템콜 인터럽트 필수?)
* https://stackoverflow.com/questions/2530663/printf-anomaly-after-fork (시스템 콜 오버헤드 문제)
* https://stackoverflow.com/questions/9238326/system-call-and-context-switch (시스템 콜의 컨텍스트 스위칭)
___
### 개요 
* [[#CPU Virtualization]]
* [[#Interrupt]]
* [[#Kernel Space, User Space]]
* [[#System Call]]
* [[#Context Switching]]
* [[#Context Switch in SystemCall]]
___
### CPU Virtualization
CPU는 한정된 자원이고 코어 1개당 1개의 작업만 실행이 가능하다. (멀티 스레드 등을 배제하면) 하지만 실제로 컴퓨터를 사용하다 보면 여러 개의 프로세스를 동시에 사용하는 일이 대다수이다. 
![[스크린샷 2023-10-15 오후 3.03.49.png]]
현재 필자의 컴퓨터에서 실행중인 프로세스 수만해도 281개인데, 안타깝게도 281 코어나 되는 CPU가 달린 엄청난 컴퓨터를 살 정도의 재력가는 아니다. 그렇다면 어떻게 하나의 코어에서 여러 개의 프로세스를 동시에 처리하는 것일까? 

<u><b>1초 간격으로 CPU의 사용권을 분할한다고 생각해보자, 이러면 CPU는 한개지만 각 초 별로 총 60명의 소유주가 존재하게 되고 이에 따라 60개의 프로세스를 동시 실행하는 것이 가능해진다.</b></u> 

하지만 생각해보면, 1초 간격으로 각 프로세스가 실행됐다 종료될 뿐 이걸 동시 실행이라 보긴 어렵다. 그렇다면 시간을 아주 잘게 쪼개 프로세스당 1000분의 1초씩을 할당하면 어떨까?

<span class="red red-bg">각 프로세스는 1000분의 1초씩 연속적으로 실행되지만, 사용자가 느끼기엔 마치 동시에 실행되는 것처럼 느껴질 것이다. 이러한 기법을 Time Slice 기법이라 하며 각 프로세스 별로 CPU의 사용 시간을 정해 주어진 시간 만큼 CPU를 프로세스에게 할당하는 기법이다.</span>

>[!info]
>**CPU의 사용 시간을 잘게 자르면 CPU가 마치 여러개인 듯한 효과를 발생 시킨다. 
>이러한 방식을 사용하는 OS를 시분할 시스템 (Time-sharing System)이라 한다.**

* **Time Slice의 성능 저하 문제**
	사용 시간을 최대한 줄이면 동시성이 더욱 높아져 좋을듯 하지만, **프로세스의 실행 시간이 짧아질 수록 프로세스가 완료되지 못하고 교체 후 다시 실행돼야 할 가능성이 발생**하게 된다. 
	이에 따라 CPU에서 프로세스의 교체가 발생해야 하는데 이를 [[#Context Switching]]이라 하고 실행중이던 프로세스의 상태를 [[프로세스#PCB]]의 형태로 저장한다.

___
### Interrupt
<span class="red red-bg">인터럽트는 외부 이벤트나 내부 이벤트가 발생했을 때 CPU가 현재 수행중인 명령을 중단하고 그 이벤트에 대해 적절한 처리를 수행하도록 하는 매커니즘을 말한다.</span>  인터럽트는 전기신호로 하드웨어나 소프트웨어에서 발생할 수 있다. 인터럽트가 발생할 경우 CPU는 현재 수행중이던 프로세스를 잠시 멈추고 인터럽트에 대응하는 작업을 우선적으로 실시한다. 인터럽트는 소프트웨어, 장치 인터럽트로 구분 가능하며 소프트웨어 인터럽트를 트랩이라 부른다.

<u><b>인터럽트는 CPU 내부에 존재하는 인터럽트 핀을 통해 전달된다. 인터럽트 핀은 각종 디바이스들과 연결돼 있으며 다양한 장치에서 발생한 인터럽트가 전부 해당 핀으로 전달된다.</b></u> INT 핀이라고도 하며 실제 이렇게 배치돼 있다. 아래의 그림은 PIC라는 장치의 그림인데 해당 장치가 모든 디바이스에서 발생한 인터럽트를 수신해 CPU의 INT 핀으로 전송해준다. (17번)
![](https://t1.daumcdn.net/cfile/tistory/2503BA3F54BA7A1214)

* **트랩 (소프트웨어 인터럽트)**
	**소프트웨어 인터럽트는 유저 프로그램 명령어 실행 오류로 인해 발생한다.** 트랩은 특정 명령어의 실행 결과로 인해 발생 하므로 동기적으로 발생한다. 잘못된 메모리에 접근하거나 0으로 나누는 작업 등이 트랩을 유발한다.

* **인터럽트 (디바이스 인터럽트)**
	인터럽트는 주로 하드웨어 디바이스에 의해 발생하며 현재 실행중인 프로세스와 관계 없이 외부요인에 의해 발생한다. 인터럽트는 외부 요인으로 인헤 발생하므로 비동기적으로 발생한다.

인터럽트가 발생하면 현재 실행하던 프로그램을 중지하고 인터럽트로 발생한 이벤트 처리를 우선 처리해야 한다. 이에 따라 **현재 프로세스의 상태 저장 -> 인터럽트 벡터 검색 -> 인터럽트 수행 -> 기존 상태로 북구의 실행 흐름**을 갖는데 이는 아래와 같다. <u><b>인터럽트를 실행할 경우 모드가 커널모드로 전환 되며 커널 영역의 작업을 수행할 수 있게 된다.</b></u>
![](https://i.imgur.com/sA0vHHB.png)

* **인터럽트 벡터란**
	**인터럽트 벡터란 인터럽트 루틴을 매핑하고 있는 테이블**을 의미한다. 즉, 어떤 인터럽트가 발생했을 때 어떠한 작업(루틴)을 실행하면 되는지를 알려주는 데이터라고 보면 된다. 이는 시스템 콜의 콜 테이블과 비슷하며 실제로 시스템 콜 또한 128번으로 벡터 테이블에 등재돼 있다.
___
### Kernel Space, User Space
커널 영역과 유저 영역은 운영체제가 메모리 공간을 분리하는 방법이다. 
* **커널 영역**
	* **커널을 실제 실행하는 영역이다**
	* 일반적으로 메모리의 상위주소에 위치한다.
	* 시스템 콜, 디바이스 드라이버 등 운영체제의 핵심적인 프로세스들이 존재하는 영역이다.

* **유저 영역**
	* **사용자 프로그램을 실행하는 영역이다.**
	* 사용자 영역에서 실행하는 프로그램은 커널 영역에 직접 접근 할 수 없다.

* **영역을 분리한 이유**
	사용자가 만든 프로그램이 마구 잡이로 메모리에 데이터를 읽거나 쓸 수 있다 생각해보자. 이 경우 타 프로세스가 사용중인 PCB를 마음대로 수정하거나 스케줄러에 직접 접근해 특정 프로세스가 평생 처리 불가하게 만들 수 있다. 
	
	이로 인해 <u><b>프로세스가 먹통이 되거나 OS가 죽는등 안정성에 문제가 발생하기에 시스템에 심각한 장애를 불러일으킬 수 있는 커널과 관련된 부분은 직접 접근 할 수 없게 커널과 유저 영역으로 분리했다.</b></u>

>[!info]
><span class="red red-bg"><b>커널 영역을 분리하지 않으면 재앙이 발생할 수 있다.</b></span>

___
### System Call
<span class="red red-bg">시스템 콜은 유저영역에서 커널과 소통하기 위해 사용하는 API이다. </span>시스템 콜을 통해 유저는 커널과 교류해 하드웨어를 다루는 IO 작업을 수행할 수 있다. 유저는 무조건 시스템 콜을 통해서만 커널영역에 접근이 가능하기 때문에 OS는 시스템 콜을 통해 유저의 행동을 제한한다. 시스템 콜은 아래와 같이 동작한다. 

![[Pasted image 20231019130102.png]]

1. **프로세스에서 시스템 콜 호출** 
2. **프로세스 커널 모드 전환**
3. **시스템 콜 인터럽트 발생**
4. **인터럽트 벡터 확인**
5. **시스템 콜 테이블 이동**
6. **시스템 콜 실행**
7. **결과 반환**
8. **사용자 모드로 전환**

* **커널모드와 유저모드**
	커널 모드는 하드웨어를 직접 제어하는 CPU 명령어를 사용할 수 있는 모드를 말한다.
	유저 모드는  하드웨어를 직접 제어하는 CPU 명령어를 사용할 수 없는 모드를 말한다.

시스템 콜을 실행하면 프로세스가 커널 모드로 변경되며 커널 영역을 다루는 시스템 콜을 실행할 수 있게된다. 커널 모드로의 전환은 인터럽트를 통해서 진행된다. 즉, <u><b>유저 영역에서 시스템 콜을 호출한 후 커널 영역에 존재하는 시스템 콜을 접근 하기 위해서 트랩을 발생시켜 모드를 전환하고 이후 시스템 콜 루틴을 수행한다. 완료된 이후에는 호출 지점으로 복귀하고 모드 또한 복구한다.</b></u>

* **시스템 콜을 쓰려면 트랩이 필수인가요?**
	시스템 콜을 사용하면 커널 영역 접근을 위한 모드 전환이 필수적이다. 따라서 모드 전환을 위한 인터럽트 또한 필수적일 것 같지만, 이는 아키텍쳐 구조에 따라 상이하다. **x86과 같은 CISC 아키텍쳐의 경우 인터럽트 없이 곧장 시스템 콜을 호출하는 구조 등을 지원**한다고 한다. RISC 구조의 아키텍쳐에서는 필수이다.
___
### Syscall and C standard Library
IO 작업이나 디바이스와 연관된 작업을 수행하기 위해선 시스템 콜의 도움이 필수적이라 했다. 하지만 일반적으로 C 프로그래밍을 할 때 명시적으로 시스템 콜을 호출해 입,출력을 처리한 경험을 떠올려 보면 잘 떠오르지 않는다.
```c
int main(){
	printf("Hello world");
	return 0;
}
```
위의 코드를 실행하면 Hello World가 잘 출력된다. 즉, IO 작업이 수행됐는데 우리는 시스템 콜의 흔적을 찾을 수 없다. 이는 **C 라이브러리가 시스템 콜을 전부 감싸고 있기 때문이다. printf 함수의 구현 부를 살펴보면 내부에서 wirte() 시스템 콜을 호출하는 것을 확인 할 수 있다.** 아래는 실제 위의 코드를 실행했을 때 실행된 시스템 콜의 로그이다. write() 시스템 콜이 호출되는 것을 확인할 수 있다.
![[2023-10-16_12.13.08.png]]

* **Systemcall Overhead**
	**시스템 콜은 모드의 변경과 프로세스의 상태 변경 등의 작업이 요구 되므로 일반적인 함수에 비해 
	오버헤드가 발생**한다. 이에 따라 **write() 같은 함수는 호출할 때 버퍼를 채워 한번에 실행하는 형태로 구현**돼 있다. 이렇게 모아서 처리할 경우 시스템 콜을 효율적으로 운영해 오버헤드를 줄일 수 있다. 
	
	이로 인해 출력에서 예상치 못한 문제가 발생하기도 하는데 대표적으로 아래와 같은 <a href="https://stackoverflow.com/questions/2530663/printf-anomaly-after-fork">문제</a>가 존재한다. 
	![[스크린샷 2023-10-16 오후 2.01.59.png]]
	fork()이후 출력 이상이 발생하는 위의 문제는 부모의 printf에서 호출한 문장이 출력 버퍼에 저장만 될 뿐 출력이 즉각적으로 이뤄지지 않는 현상 때문에 발생한다. **printf는 버퍼에 데이터를 모았다 출력을 진행하고 만약 '\\n'을 만나면 즉시 출력을 실행한다**. 위의 경우 개행 문자가 없으므로 버퍼를 비우며 출력을 하지 않고 자식 프로세스에도 버퍼를 복사하고 이중 출력 문제를 일으킨다. **출력하고자 하는 문장 끝에 '\\n'을 붙여 즉각적으로 버퍼가 비워지게 처리하면 문제를 해결할 수 있다.**
___
### Context Switching
<u><b>인터럽트나 트랩이 발생하면 기존의 프로세스는 잠깐 중단됐다 다른 프로세스를 실행하는 경우가 많이 발생한다. 이 경우 현재 프로세스의 상태를 저장, 복원할 필요성이 발생하는데 이때 사용되는 것이 문맥 교환(Context Switching) 이다. </b></u>
프로세스 전환을 위해 운영체제는 <span class="red red-bg">현재 실행중인 프로세스의 범용 레지스터, PC뿐 아니라 커널 스택 포인터를 저장한다. 그리고 곧 실행될 프로세스의 범용 레지스터, PC를 로드하고 커널 스택 포인터를 교체한다. </span>이로써 운영체제는 인터럽트될 프로세스에서 전환 코드를 호출하고, 실행할 프로세스 문맥으로 스위칭할 수 있다. 
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdvX85X%2FbtrySOfoDCC%2FGbykWLxqVTOVJW9vbiv3ak%2Fimg.png)

>[!info]
>**컨텍스트 스위칭이 발생하는 동안 CPU는 작업을 수행할 수 없기 때문에 컨텍스트 스위칭이 자주 발생하면 CPU의 효율이 저하된다.**

* **Dispatcher**
	**디스패쳐는 스케줄링을 통해 선정된 프로세스를 CPU에 업로드 하는 역할을 수행하는 모듈**을 말한다. 스케줄러가 스위칭할 프로세스를 선택하면  <u><b>디스패쳐는 모드 변환, 실행 위치로의 복귀 컨텍스트 스위칭 작업을 수행해준다.  </b></u> 디스패쳐가 하는 작업이 디스패칭이며 여기에 컨텍스트 스위칭 또한 포함된다.
___
### Context Switch in SystemCall
시스템 콜을 호출하면 컨텍스트 스위칭이 발생할까? <span class="red red-bg">모든 시스템 콜에서 컨텍스트 스위칭이 발생하는 것은 아니다.</span> 예를 들어 1 + 1을 수행하는 시스템 콜이 존재한다고 해보자. 이 경우 프로세스의 모드를 전환, PC와 커널 스택 포인터 등을 전환할 필요는 있으나, 페이지 테이블까지 전부 다 교체할 필요는 전혀 없다. **가벼운 스위칭만으로도 충분하다는 것이다.**

반대로 <span class="red red-bg">IO가 발생하면 해당 프로세스로 금방 돌아올 수 없기에 완전히 새로운 프로세스가 실행 가능하게 준비를 해야한다. 이에 따라 IO 작업이 발생하면 OS는 강제로 프로세스의 컨텍스트 전체를 PCB로 저장하고 교체를 진행한다. </span>
![[스크린샷 2023-10-16 오후 4.32.40.png]]

> [!info]
> **시스템 콜과 인터럽트 모두 컨텍스트 스위칭을 필수적으로 발생시키지 않는다.**


