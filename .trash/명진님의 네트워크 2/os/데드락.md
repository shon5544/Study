### 출처
* https://velog.io/@minseojo/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94-%EC%B2%A0%ED%95%99%EC%9E%90-%EB%AC%B8%EC%A0%9C (식사하는 철학자)
* https://velog.io/@bbamjoong/18.-%EB%8D%B0%EB%93%9C%EB%9D%BD%EA%B3%BC-%EB%B1%85%EC%BB%A4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Chapter-8.-Deadlocks-Part-2 (교착 상태 회피)
___
### 개요
* [[#데드락]]
* [[#데드락의 조건]]
* [[#식사하는 철학자 문제]]
* [[#자원할당 그래프]]
* [[#데드락 예방]]
* [[#데드락 회피]]
* [[#은행원 알고리즘]]
* [[#데드락 회복 알고리즘]]
* [[#현대 OS의 데드락 처리]]
___
### 데드락

<b><u>데드락은 두개 이상의 경쟁하는 행동이 서로 다른 것이 먼저 끝나기를 기다릴 때 발생한다. 아래와 같은 상황을 데드락이라 한다.</u></b>
![[Pasted image 20231207232002.png]]
쓰레드 1이 자원 1을 릴리즈 하지 않아 쓰레드 2는 대기하고 자원2를 릴리즈 하지 못한다. 반면 쓰레드 1은 자원 2가 릴리즈 되지 않아 자원 1을 릴리즈 하지 못한다. 이 처럼 꼬리에 꼬리를 물고 아무도 동작하지 못하게 되는 상황을 데드락이라 부른다.
___
### 데드락의 조건

- **상호배제**
    한번에 한 프로세스만이 자원을 사용할 수 있다.
- **점유 및 대기**
    자원을 대기하면서 이미 다른 자원을 사용하고 있다.
- **비 선점**
    프로세스가 점유한 자원을 뺏기지 않는다.
- **환형 대기**
    프로세스가 자원을 대기하면서 점유하는 그래프가 원형 형태로 만들어지는 것을 말한다. **위의 이미지 같은 상황이 발생하는 것**을 말한다.

==**4가지 조건을 모두 만족해야 데드락이 발생한다.**== 발생할 일이 희귀할 것 같지만 생각보다 발생하는 경우가 종종 존재한다.

**데드락은 반드시 처리돼야 하며 데드락을 처리하는 방법은 4가지가 존재한다.**
* 데드락의 발생을 100% 방지하는 예방 기법
* 데드락이 발생할 수 있으나 발생하지 않게 하는 회피 기법
* 데드락이 발생했을 경우 회복하는 방법
* 데드락을 무시하는 방법 등이 있다.
___
### 식사하는 철학자 문제

![[Pasted image 20231208114540.png]]

철학자 다섯이서 원탁에 앉아 밥을먹는다 이때 젓가락은 5개 밖에 존재하지 않는다. 철학자들은 아래의 행동을 순서에 따라 반복한다.

1. 왼쪽 젓가락을 집는다. 누가 사용중이면 대기한다.
2. 오른쪽을 집는다. 누가 사용중이면 대기한다.
3. 젓가락을 모두 집었으면, 식사를 한다.
4. 식사를 마쳤으면 젓가락을 모두 내려놓는다.

철학자들이 다 같이 식사를 진행하려하면 동시에 젓가락 한 개를 들고 대기하기 때문에 아무도 식사를 하지 못하는 교착상태가 발생하다가 모두 굶어 죽는 현상이 발생하게 된다.

**식사하는 철학자 문제는 교착상태의 4가지 조건을 모두 만족하는 대표적인 문제**이다. 젓가락은 선점되지 않으며, 원형대기가 발생한다. 또한 젓가락을 동시에 두명의 철학자가 공유해 사용할 수는 없다(상호배제). 또한 젓가락 한개를 든채로 다른 젓가락을 대기한다.(Hold-Wait)

위의 4가지 중 하나만 회피 가능해도 교착상태를 회피할 수 있으므로 **식사하는 철학자 문제는 다양한 방법으로 해결**할 수 있다.

- **집는 순서 변경하기**
    짝수 번째의 철학자는 오른쪽부터 젓가락을 들고 홀수 번째 철학자는 왼쪽부터 젓가락을 집으면 모두가 동시에 젓가락을 1개씩 집은 체 환형으로 대기하는 상황을 방지할 수 있다.

- **젓가락 수 늘리기**
    젓가락 수를 늘리면 적어도 1명의 철학자는 식사를 진행하므로 데드락을 풀 수 있다.

- **젓가락 1개로 먹기**
    젓가락 1개로 먹는 법을 터득해도 된다.
___
### 자원할당 그래프

**프로세스와 자원 사이의 관계를 표기하기 위한 그래프이다.** 이때 프로세스 → 자원을 요청선이라 부르고 자원 → 프로세스를 할당선이라 한다. 할당 그래프를 사용하면 프로세스의 데드락 여부를 확인 할 수 있다.
![[Pasted image 20231207232819.png]]

위의 그림은 **교착 상태가 발생하는 그래프의 모습**이다. 그래프를 살펴보면 P1이 종료 가능한 프로세스 처럼 보이지만 사실 P1은 P2로인해 이미 선점돼 있는 R1의 자원을 획득하지 못해 종료되지 않는다. 또한 P2 역시 P3에 의해 선점된 R2로 인해 종료되지 못하고 P3는 P2, P1이 R3 의 자원을 사용하고 있어 종료되지 못한다. 꼬리에 꼬리를 무는 환형대기가 발생하며 데드락이 발생하는 것을 확인할 수 있다.

문제는 간단히 해결 할 수 있는데, 가장 쉬운 방법은 R3에 자원을 한개 더 추가해주는 것이다. 혹은 이미 선점된 자원에 한해서는 요청을 못하게 할 수도 있다.
___
### 데드락 예방

- **순환 대기 방지**
    세마포어나 뮤텍스 등을 활용해 실행 순서를 강제해 환형대기가 발생하지 않게 한다. 자원이 할당되는 순서를 정해 놓는 방식을 말한다. 프로그래머가 완벽하게 강제할 수 없다는 단점이 존재한다.

- **Hold-and-Wait 삭제**
    **프로세스에게 필요한 자원을 미리 전부 할당해 놓고 락을 걸어버리는 방법**을 말한다. 이에 따라 프로세스는 다른 자원을 위해 대기할 필요가 없어지므로 데드락이 발생하지 않는다. 다른 방법은 **프로세스가 어떤 자원도 갖고 있지 않을 경우에만 할당을 진행**하는 것이다. 이 경우 프로세스가 다른 자원에 종속성을 가질 경우  기아가 발생할 수도 있다.

- **선점 사용**
    **프로세스가 자원이 필요할 경우 자신의 자원을 모두 해제한 다음 새로운 자원을 가질 수 있게 만든다. 이후 다시금 기존 자신의 자원을 요청해 할당 받으면 필요 자원을 모두 할당 받을 수 있다.** 굳이 해제 후 할당하는 이유는 프로세스의 자원 독점을 방지하기 위해서이다.
    이 방법은 데드락을 예방할 수 있지만, 기존에 사용하던 자원을 복구 하는 연산을 진행해야 한다. 이때 기존 자원을 다른 프로세스가 사용중이면 추가 대기가 필요할 수도 있다. 이에 따라 복구가 쉬운 프로세스라면 유용하지만 아닐 경우 오버헤드가 큰 방법이다.

- **Mutual Exclusion**
    공유 가능 자원에 복수 개의 프로세스가 접근 할 수 있게 설정한다. 한 자원을 여러 프로세스가 이용할 수 있으나 경쟁 조건 등의 문제가 또다시 발생한다.

**위의 방법들은 교착 상태를 완벽하게 예방하지만 오버헤드가 큰 방법이라 사용하지 않는다**. 위의 방법보다 오버헤드가 적은 교착 상태 방지나 회복을 주로 사용한다.
___
### 데드락 회피

<span class="red red-bg">데드락 회피는 데드락을 100% 방지하는 예방과는 달리 데드락이 발생할 수 있는 상황을 감지하고 해당 상황을 회피하는 방식을 말한다.</span> 데드락이 발생할 수도 있다는 것을 인지하고 이를 회피하는 방식이고 **데드락 예방보다 오버헤드가 적고 성능이 빠른 방식이다.**

<b><u>데드락 회피 알고리즘은 교착상태를 피할 수 있는 방법으로 자원을 할당한다.</u></b> 이에 따라 교착 상태 발생 가능성을 프로세스 시작 전에 파악해야 하기 때문에 프로세스에서 활용할 자원의 양과 사용 가능한 자원을 명확히 파악 해야만 한다. 

데드락 회피 방법으로는 크게 프로세스 시작 거부와 자원 할당 거부 2개가 존재한다.

- **프로세스 시작 거부**
    **프로세스가 시작되기 위한  자원이 부족할 때 실행을 거부하고 다른 프로세스가 자원을 반납할 때 까지 대기 하는 방법이다.** 프로세스마다 자원의 요청과 해제의 정확한 순서를 파악하고 요청에 따른 프로세스 대기 여부를 결정한다.

* **자원 할당 거부**
	대표적으로 은행원 알고리즘이 있다. <u><b>은행원 알고리즘은 안정상태를 유지할 수 있는 요구만을 수락하고 불안전 상태를 초래할 요구는 조건이 충족될 때까지 거절하는 알고리즘이다.</b></u> 프로세스가 요청하는 자원이 할당 가능한 경우에만 프로세스의 실행을 수락하고 아닌 경우 프로세스를 계속해서 대기 시킨다. 이를 위해선 프로세스가 최대 요청할 자원의 크기, 현재 가용 가능한 자원의 크기를 항시 확인하고 있어야 하는데 오히려 매번 프로세스를 실행할 때 마다 이런 연산을 진행하는 것이 더욱 오버헤드가 더 클 수도 있다는 모순이 존재한다.

>[!info]
>**회피 알고리즘은 프로세스의 자원 할당, 요청 현황을 보고 프로세스가 데드락이 발생하는 위험 상태에 이르지 않게 한다.(unsafe에 머물게한다)** 

![[스크린샷 2023-12-08 오전 12.16.21.png]]
___
### 은행원 알고리즘

$C$는 현재 프로세스가 필요로 하는 자원 행렬을 $A$는 프로세스에 이미 할당된 자원의 행렬을 의미한다 했을 때. 프로세스의 가용을 위해 필요한 행렬은 $C - A$가 된다. 또한 R은 전체 자원의 벡터이고 $V$는 현재 할당 가능한 벡터라고 하자. 이때 $A+V = R$ 의 수식이 성립하는데 이는 할당된 행렬과 활용 가능한 벡터를 합치면 전체 리소스 행렬이 되기 때문이다. $V$를 활용해 할당시 종료가 가능한 프로세스에 자원을 할당해준 뒤 프로세스를 끝낸다. 이후 해당 프로세스에 할당됐던 자원을 회수해 $V$에 추가해준다. 즉, $V=P_i+V$가 성립한다.

이를 계속 반복하면서 프로세스를 종료한다. 만약 **더 이상 어떤 프로세스에도 자원을 할당 할 수 없다면, 이는 데드락이다. 반대로 모든 프로세스가 실행 가능하다면 데드락이 아니다**

![[스크린샷 2023-12-08 오전 12.21.48.png]]
___
### 데드락 회복 알고리즘
데드락 상태에 빠졌을 때 회복을 진행하는 방법이다. **회복을 진행하기 위해선 우선적으로 현재 상태가 데드락임을 감지할 수 있어야 하는데 이를 감지할 수 있어야 한다**. 탐지는 자원 할당 그래프를 사용하거나 은행원 알고리즘과 유사한 알고리즘을 활용해 진행한다. 

탐지 알고리즘을 활용해 데드락을 감지하면 회복 알고리즘을 활용하는데 상태 회복은 크게 종료와 선점으로 구현한다. 

**종료로 해결하기**
- **교착상태에 포함돼 있는 모든 프로세스를 죽인다.**
    - 프로세스의 현재까지의 작업 내역을 모조리 삭제하기에 부담이 큰 방법이다. 하지만 확실히 회복한다.

- **교착 상태가 제거될 때까지 포함된 프로세스를 하나씩 종료한다.**
    - **종료할 때 마다 교착 상태 여부를 다시금 확인**해야 하고 어떤 프로세스 부터 죽일지 결정하는데 오버헤드가 발생한다.

**선점으로 해결하기**
- 비용이 가장 적은 자원을 선택해 다른 프로세스가 선점 가능하게 설정한다. 이후 교착상태 발생여부를 다시금 탐지한다. 자원을 뺏긴 프로세스는 자원을 할당 받기 전으로 롤백하고 다시 실행한다. **동일한 프로세스가 연속해서 자원을 뺏기며 기아 문제가 발생할 수 있다.**

탐지 알고리즘을 자주 호출 하는 것은 오버헤드가 크기 때문에 이를 적절히 호출하는 것이 중요하다. 이에 따라 정해진 주기나 이벤트가 발생했을 때만 호출한다.
___
### 현대 OS의 데드락 처리

**현대 os는 데드락을 따로 회복하지도 회피하지도 예방하지도 않는다. 데드락이 발생하면 데드락의 처리는 사용자에게 맡겨버린다. (무시)** 이와 같은 방식으로 설계를 하는 이유는 애시 당초 OS단에서 데드락이 발생하는 경우가 희소하기 때문에 별도의 처리를 하는 것이 오버헤드가 더 크기 때문이다.
___
