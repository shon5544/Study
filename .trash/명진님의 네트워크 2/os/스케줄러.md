### 개요
* [[#CPU / IO bound]]
* [[#Scheduler]]
* [[#Job Queue, Ready Queue, IO Queue]]
* [[#Process Scheduling Condition]]
* [[#Long, Mid, Short Term Scheduler]]
* [[#Criteria of Schedular]]
* [[#Preemption VS Non Preemption]]
___
### CPU / IO bound
프로세스는 크게 CPU bound와 IO bound로 구분된다. **<u>CPU bound는 CPU에서 집중적으로 처리하는 것을 의미하고 반대로 IO bound는 IO 대기가 주가 된다는 것을 말한다.</u>**

프로세스가 어디에 bound 될지는 burst가 주로 어디에서 발생하는지로 결정 된다. burst는 연속해서 프로세스가 실행되는 것을 의미하는데 **<u>만약 CPU를 IO 대기시간보다 오래 활용한다면 해당 프로세스는 CPU bound가 된다. 반대로 프로세스가 CPU를 거의 활용하지 않고 IO를 대기하는 IO burst가 잦다면, IO bound 프로세스가 된다.</u>**

> <span class="red-bg red">CPU bound는 연산이 주가되고 IO bound는 입출력 대기가 주가 된다.</span>

___
### Scheduler
대다수의 프로세스는 연산과 IO 작업이 복합적으로 얽혀있다. 만약 하나의 프로세스를 단순 실행한다면 아래와 같을 것이다. 
![[스크린샷 2023-10-06 오후 4.58.02.png]]

단순 실행을 할 경우 프로세스는 잘 실행 되겠지만, **<u>CPU가 idle(대기) 상태인 시간이 많아져 비효율이 발생한다. IO 대기시간 동안 CPU가 그저 대기하는 상황이 발생하기 때문이다.</u>**
이에 따라  CPU  대기 시간을 최소화해 CPU를 효율을 극대화 하는 방법에 대한 연구가 진행됐고 이로 인해 스케줄러가 탄생했다.

> <span class="red-bg red">스케줄러의 목적은 연산과 IO가 섞여있는 다수의 프로세스 테스크들을 효율적으로 처리해 CPU 가용성을 극대화 하는 것이다. </span>

**<u>운영체제는 CPU의 효용성을 높이고 대기 시간을 줄이기 위해 대기가 발생한 프로세스는 잠시 보류하고 다른 연산이 필요한 프로세스에게 CPU를 할당해주는 방법을 사용</u>한다. 이렇게 CPU를 적절히 할당하고 뺏어오는 행위를 스케줄링이라하고 이를 OS의 스케줄러가 실시한다.
___
### Job Queue, Ready Queue, IO Queue
스케줄러가 프로세스를 스위칭 하려면 실행하고 싶은 혹은 실행중인 프로세스 들을 어느곳에 저장해둘 필요가 존재한다. Job Queue는 메모리 할당을 위해 대기하는 프로세스들의 집합을 의미하고 Ready Queue는 이미 실행 중인 CPU 할당을 위해 대기하는 프로세스들의 집합을 의미한다.

Job Queue는 곧 실행 할 프로세스를 저장하는 큐인데, 해당 큐에서의 스케줄링은 자주 발생하지 않기 때문에 큐를 관리하는 스케줄러를 Long Term Scheduler(장기 스케줄러)라고 부른다.
반대로 Ready Queue의 경우 이미 실행중인 프로세스들이기에 스케줄링이 빈번하게 발생한다. 따라서 해당 큐의 스케줄러를 Short Term Scheduler(단기 스케줄러)라고 부른다.
![[Pasted image 20231012160051.png]]
Job Queue와  Ready Queue가 아닌 다양한 큐가 시스템에 존재하는데 대표적으로 IO Queue가 있다.  **IO Queue는 특정 입출력 장치에 입출력 요청을 보낼때 필요한 큐로 해당 장치에 대해 요건이 있는 프로세스들이 해당 큐에 들어가게 된다**. **IO Queue는 Device Queue라고 불리기도 한다.** 아래 그림은 다양한 IO 큐와 레디 큐를 보여준다.
![[스크린샷 2023-10-12 오후 4.46.08.png]]
___
### Process Scheduling Condition
새로운 프로세스는 초기에 Ready Queue에 할당된 후 실행될 때까지 대기한다. <u><b>프로세스는 계속해서 CPU에서 실행되다 아래의 조건 중 하나를 충족하면 CPU 점유를 반환하고 Ready Queue나 IO Queue로 편입된다.</b></u>
* **프로세스에서 IO 작업이 발생하는 경우**
* **자식 프로세스를 생성해 자식 프로세스가 먼저 실행되는 경우**
* **프로세스에서 인터럽트가 발생하는 경우**
* **프로세스 실행기간이 만료되는 경우**

![[Pasted image 20231007190405.png]]
___
### Long, Mid, Short Term Scheduler
스케줄러는 스케줄링 시기와 목적에 따라 크게 3가지로 구분할 수 있다. (장, 단기로만 구분하는 경우도 존재한다.) 

<u><b>장기 스케줄러는 동시에 실행하는 프로세스의 수를 조절하는 스케줄러</b></u>로 프로세스를 실행 가능 상태로 변경하는 작업을 수행한다. 장기 스케줄러는 자주 실행되지 않기 때문에 프로세스의 IO, CPU 작업이 적절히 분배돼 있어야 한다.

장기 스케줄러는 과거 메모리가 부족하던 시절 실행하고 싶은 프로세스를 전부 적재하지 못해 사용했지만, 근래 들어 가상 메모리와 메모리 용량의 발전으로 인해 실상 사용하지 않는 기능이 됐다. 윈도우의 경우 실행하면 모든 프로세스가 Ready State가 된다.

<span class="red-bg red"><b>중기 스케줄러는 메모리에 존재하는 사용하지 않는 프로세스를 하드 디스크로 옮기는 Swapping 작업을 실행한다</b></span>.  중기 스케줄러는 메모리 효율을 증대시켜 동시 실행 프로세스 수를 늘리는 걸 목적으로 한다.

<u><b>단기 스케줄러는 이미 큐에 적재된 프로세스들 중에서 CPU를 할당 받을 프로세스를 선정하는 작업을 진행한다. </b></u> 당장 실행할 프로세스를 선정하는 스케줄러이기에 스케줄링 작업이 제일 잦고 빠르게 진행된다.
![[Pasted image 20231007192246.png]]
___
### Criteria of Schedular
- **Turnaround Time**
    프로세스가 처음 시작부터 완료되기 까지의 시간을 의미한다. 작업이 도착부터 완료까지 걸리는 시간을 최소화한다.

- **Waiting Time**
    대기 큐에 위치하며 CPU를 할당 받기 까지 기다린 시간의 총합을 의미한다.

- **Response Time**
    CPU가 프로세스에 대해 처음 작업을 수행하기까지 소요된 시간을 말한다. 작업이 첫 시작되기까지 걸리는 시간이기에 반응형 프로그램에서 무척 중요하다. **사용자가 느끼는 답답함을 줄이기 위해서 가장 우선적으로 줄여야하는 시간**이다.

- **Throughput**
    시간당 처리한 작업의 비율

- **CPU Uitlization**
    시간당 CPU를 활용한 비율. IO 작업 동안 CPU를 놀리지 않는 것이 핵심이 된다.

	**시스템 입장에서 CPU 스케줄링 알고리즘의 성능 평가로 중요한 것은 CPU 활용률과 시간당 처리 비율**이다. 반대로 **사용자 입장에선 프로그램이 완료되는 시간(Trurn around Time), 프로그램이 실행 되기까지 대기하는 시간(Response time, Waiting Time)이 중요**하다.

> [!info]
> **스케줄러의 목적은 CPU 사용률과 처리 가능한 프로세스의 수를 최대화 해  
> 프로세스의 응답시간, 대기시간, 실행시간을 최소화 하는 것이다. **

___
### Preemption VS Non Preemption

- **Preemption**
    **Preemption(선점)은 실행 중인 다른 프로세스를 인터럽트 시키면서 CPU 권한을 뺏는 행위**를 말한다. 이에 따라 Preemption한 프로세스는 **다른 프로세스에게 자원을 뺏거나 반대로 자원을 뺏길수 있다.**  

- **Non Preemtion**
    Preemtion의 반대로 자원을 뺏기지 않는 프로세스를 말한다. **Non preemtion 프로세스들은 프로세스가 블럭 상태가 되거나 종료되지 않는 이상 자원을 뺏기지 않는다. [[시스템 콜#Context Switching]] 이 발생하지 않는다고 보면 된다.**

1. Switches from running to waiting state
2. Switches from running to ready state
3. Switches from waiting to ready
4. Terminates

**스케줄러 또한 프로세스이기 때문에 구현 방식에 따라 선점 혹은 비선점으로 동작한다.** 위는 일반적으로 스케줄러가 비선점으로 처리하는 상태 변경 작업들로 <u><b>이 경우 스위칭이 발생하면 이슈가 발생할 수 있기 때문에 상태 변경 도중에는 스위칭을 진행하지 않는다.</b></u> 나머지 경우 전부 프로세스를 선점해 강제로 스케줄링을 진행한다.

> [!info]
> **선점형 스케줄러여도 항상 선점이 가능한 것은 아니다. 
> 원자성을 보장해야하는 연산들이 있다.**

___
