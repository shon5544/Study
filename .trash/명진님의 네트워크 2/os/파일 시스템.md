### 출처
* https://askubuntu.com/questions/1103937/explain-in-linux-and-unix-everything-is-a-file (모든 것은 파일이다)
* https://medium.com/naver-cloud-platform/posix-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-1-linux-%EB%A6%AC%EB%88%85%EC%8A%A4-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%ED%8A%B9%EC%A7%95-96a2e93e33b3 (유닉스 파일 시스템)
___
### 개요
* [[#파일]]
* [[#파일 시스템]]
* [[#논리 주소 변환]]
* [[#FAT 파일 시스템]]
* [[#UNIX 파일 시스템]]
* [[#i-node]]
* [[#i-node 파일 접근하기]]
* [[#파일 입출력]]
* [[#디스크 블록 관리 방법]]
___
### 파일

<b><u>"리눅스의 모든 것은 파일이다" 라는 말이 있을 정도로 리눅스에서 정의하는 파일의 범위는 넓다.</u></b> 리눅스는 표준 입출력, 네트워크 소켓, 파이프, 드라이버 뿐만 아니라 [[프로세스#PCB in Linux|PCB]]에서 설명했던 실시간으로 CPU의 상태를 보여주는 proc 또한 파일로 취급한다.

파일은 디스크에 저장되는 데이터라는 선입견이 존재하는 까닭에 이러한 철학이 쉽게 와닿지는 않는다. 하지만 파일은 제한된 범위의 데이터만을 의미하지 않는다. <u><b>데이터가 집약돼 있다면 그것은 곧 파일이다. 즉 데이터가 메모리에 있던 디스크에 있던 어떤 타입이건 모여 있다면 해당 객체는 파일이 된다는 것이다.</b></u> 그렇다고 proc이나 드라이버가 일반적인 파일이라는 것은 아니다. **이는 특수 파일로 일반 파일과는 형태가 다르다. 하지만 파일 시스템 아래에 속하는 파일이라는 것은 동일하다.**

<span class="red red-bg">리눅스는 스트림 데이터로 구성되고 열고 닫고 읽고 쓰는 것이 가능한 데이터들을 전부 파일로 취급한다.</span> 앞서 언급한 객체들은 전부 파일 시스템에 등록돼며 파일 디스크립터 값도 할당 받을 수 있다. 몰론 inode도 갖는다. **리눅스는 이런 다양한 객체들을 파일이라는 하나의 인터페이스로 통합해 파일 시스템에서 관리**한다.

> [!info]
> "모든 것은 파일이다" 는 아직 논쟁 중인 부분이 많다. "모든 것은 바이트 스트림이다" 혹은 "거의 모든 것은 파일 시스템에서 표현된다" 정도로 타협하고 있는 듯 하다.

___
### 파일 시스템

<span class="red red-bg">컴퓨터에서 파일이나 자료를 쉽게 발견 및 접근할 수 있도록 보관 또는 조직하는 체제를 가리키는 말이다. </span> **파일 시스템은 커널 프로세스이며 메모리에 상주한다.** 만약 파일 시스템이 없다면 파일을 열거나 닫는 작업 들을 개별 구현해야 할 것이다. 

파일 시스템은 FAT, EXT등이 존재하고 디스크의 파티션 별로 다르게 사용할 수 있다. 이에 따라 하나의 운영체제에서 다양한 파일 시스템을 사용하는 것이 가능하다. <b><u>파일 시스템은 i-node, 슈퍼블록, 오픈 파일 테이블 등을 관리하고 사용자가 읽는 파일 바이트를 논리 블럭으로 변환하는 작업 등을 수행한다. </u></b>하지만  실질적인 데이터 입,출력은 각 하드웨어의 드라이버가 수행한다. 
___
### 논리 주소 변환

파일을 저장할 때도 단편화 문제는 존재한다. 이에따라 <b><u> OS는 실제 파일 데이터를 블럭 단위로 디스크 곳곳에 분산 저장하고 논리 주소를 사용해 파일이 마치 연속할당 돼있는 것처럼 사용자에게 알려 준다.</u></b> 이는 가상 메모리에서 사용했던 기법과 흡사하며 파일 시스템 또한 페이지 테이블과 같이 **사용자가 사용하는 파일 바이트 접근 주소를 파일 시스템이 사용하는 논리 주소로 변환하기 위한 별도의 자료구조가 요구된다.**

* **가상 메모리의 접근 순서**
	가상 주소 -> 페이지 테이블 -> 실제 주소

* **논리 블럭 접근 순서**
	 파일의 바이트 주소 -> (테이블 or inode) -> 실제 주소

![[스크린샷 2023-12-08 오후 4.14.33.png]]
___
### FAT 파일 시스템

![[스크린샷 2023-12-08 오후 4.36.42.png]]

* **부트 섹터(boot sector)**
	운영체제 초기 코드를 적재하고 실행시키는 코드

* **FAT1, FAT2**
	FAT(File Allocation Table)는 파일 블록 들의 할당 테이블로 파일 바이트 주소를 논리 블럭 주소로 변환할 때 사용한다. FAT2는 FAT1의 복사본으로 FAT1의 손상을 대비해 존재한다.

* **루트 디렉토리**
	최상단에 위치한 디렉토리로 고정 크기이다. 생성되는 파일이나 서브디렉토리의 개수는 유한하다.

* **데이터 블록들**
	실제 파일 데이터를 쪼갠 블록으로 파일 블록들은 분산 저장된다.

**FAT 파일시스템은 테이블을 계속해서 참조해 파일 블럭을 읽어 나가는 방식으로 동작한다.** 이때 파일 엔트리의 블럭 번호가 -1이면 파일의 끝을 나타낸다. 따라서 테이블을 탐색하는 행위를 -1을 만날 때까지 반복하다. 블럭을 전부 찾으면 종료한다. 하나의 파일을 읽는 데도 여러번의 접근이 필요하다.

![[스크린샷 2023-12-08 오후 4.51.40.png]]
___
### UNIX 파일 시스템
![[스크린샷 2023-12-08 오후 4.58.44.png]]

유닉스 파일 시스템은 유닉스에서 사용하는 파일 시스템으로 FAT과 달리 **inode와 수퍼블럭 이라는 구조체를 활용한다**. 

* **수퍼 블록**
	파일 시스템을 기술하는 정보를 저장하며 파일 시스템마다 하나씩 존재한다. 슈퍼 블록 내부에는 파일 시스템의 메타 정보(이용 가능 블록수, 시스템의 크기, 아이노드의 수 등)들이 저장된다

#### i-node

**파일을 서술하는 데이터 구조로 모든 파일마다 존재하며 데이터 블록의 위치 파일의 권한, 소유권 허가권 등의 파일과 관련된 모든 정보를 갖는다.** 아이 노드는 index-node의 줄임말로 논리 블럭의 인덱스를 갖는다. 따라서 아이노드에 접근하면 인덱스 정보를 통해 해당 파일의 논리 블럭을 빠르게 접근 할 수 있다. 

이때 블럭을 직접적으로만 가리키면, 가리킬 수 있는 블럭의 수가 제한적이기 때문에 인덱스로만 채워진 포인터 블럭을 활용한다. **포인터 블럭은 싱글 포인터, 더블 포인터, 트리플 포인터 3개가 존재하는데 이를 활용하면 하나의 아이노드로도 큰 크기의 파일을 가리킬 수 있다.** 

데이터 블럭 크기가 4KB고 포인터의 크기가 4B라 해보자. 이때 싱글 인다이렉트 포인터 블럭은 1024개의 블럭을 가리킬 수 있으므로 총 1024 X 4KB=4MB가 된다. 더블 포인터는 포인터 블럭을 또 다시 가리키므로 싱글 인다이렉트 앞에 1024개가 더 붙어 4GB가 된다. 트리플은 마찬가지의 이유로 4TB가 된다. 

<b><u>일반적인 리눅스 아이노드에는 싱글, 더블, 트리플이 인다이렉트 포인터가 각각 1개 다이렉트 포인터가 12개 존재한다.</u></b> 따라서 위에서 가정한 하나의 아이노드가 가리킬 수 있는 최대한의 크기는 48KB + 4MB + 4GB + 4TB가 된다. 

![[스크린샷 2023-12-08 오후 5.20.19.png]]
___
### i-node 파일 접근하기

![[스크린샷 2023-12-08 오후 5.30.38.png]]

아이노드를 활용해 파일을 읽는 예시를 진행해보자. /usr/source/main.c라는 파일을 읽는다고 가정할 때 읽는 순서는 아래와 같다.

1. 슈퍼 블럭에서 루트 디렉토리의 inode를 가져온다.
3. 루트의 i-node 인덱스를 타고 루트 디렉토리의 데이터 블럭을 읽는다.
4. 루트 디렉토리 데이터 블럭에서 usr 디렉토리의 i-node 값을 얻는다.
6. /usr 의 i-node 인덱스를 타고 usr 디렉토리의 데이터 블럭을 읽는다.
8. usr 디렉토리 데이터 블럭에서 source 디렉토리의 i-node 값을 얻는다.
9. source의 i-node 인덱스를 타고 main.c의 i-node 값을 얻는다.
10. /usr/source/main.c 파일 읽기
___
### 파일 입출력
#### 파일 열기
파일을 열때 운영체제는 다음과 같이 동작하며 파일을 열어준다.

1. 파일의 경로를 통해 파일의 i-node를 획득한다.
2. 해당 파일의 i-node를 커널 메모리의 i-node 테이블에 적재한다.
3. 오픈 파일 테이블에 새 항목을 추가한다.
4. **==오픈 파일 테이블의 인덱스를 리턴한다. 이때 반환하는 값이 파일 디스크립터이다.**==

* **파일 디스크립터란?**
	리눅스 혹은 유닉스 계열의 시스템에서 프로세스(process)가 파일(file)을 다룰 때 사용하는 개념으로, 프로세스에서 특정 파일에 접근할 때 사용하는 추상적인 값이다. **파일 디스크럽터는 일반적으로 0이 아닌 정수값을 갖는다.** 
	==**프로세스가 실행 중에 파일을 Open하면 커널은 해당 프로세스의 파일 디스크립터 숫자 중 사용하지 않는 가장 작은 값을 할당해준다.==이후 프로세스가 열려있는 파일에 시스템 콜을 이용해서 접근할 때, 파일 디스크립터(FD)값을 이용해서 파일을 지정할 수 있다.

#### 파일 읽기
파일을 읽는 과정은 아래와 같다. 파일을 열때 i-node 생성 등의 사전 작업은 진행했기 때문에 디스크에서 실제 데이터 블럭을 가져오는 작업을 진행하면 된다.

1. 파일 디스크립터를 활용해 오픈 파일 테이블을 참조한다.
2. 파일 테이블의 offset을 블럭 번호로 변환한다.
3. i-node테이블로 접근해 i-node를 찾고 필요 블록 리스트를 확보한다.
4. 필요한 블럭이 버퍼 캐시에 있는지 확인한다.
5. 캐시에 있을 경우 유저 영역에 복사하고 없을 경우 디스크에서 캐시로 로딩한다.
___
### 디스크 블록 관리 방법

파일을 디스크에 쓰려고 한다면 **파일의 데이터를 여러 개의 블럭에 나누어 디스크에 할당**해야 한다. 이때 사용하는 여러 개의 블럭을 어떻게 선정하고 관리할 지가 고민해야 한다. 블럭에 파일을 할당하는 방법은 크게 연속할당과 불연속 할당이 존재한다.

- **연속할당**
    **파일이 디스크 내에서 연속적으로 공간을 차지하도록 저장하는 방법**이다. 파일의 데이터는 **순차적으로 블럭에 할당**된다. 이 경우 파일을 읽고 싶다면 파일의 시작 위치와 크기만 알면 디스크에서 손쉽게 읽을 수 있다.
    
    **연속할당 방법은 쉽게 구현이 가능하고 연속적으로 데이터를 읽으면 되므로 속도가 무척이나 빠른 방식**이다. 하지만 **단편화가 심하다는 단점**을 갖는다. 연속 할당은 삭제, 수정으로인한 빈공간이 발생하면 연속된 공간을 활용 해야만 한다는 특징으로 인해 중간에 존재하는 틈을 활용하지 못한다. 따라서 중간 중간 노는 디스크가 발생하는 단편화 현상이 발생한다. 또한 파일의 크기를 정확히 파악하기 어렵다는 특징이 존재한다.

![[Pasted image 20231208180820.png]]

- **연결할당**
    연속 할당의 단편화를 해결한 방법으로 각 블록을 포인터를 활용해 연결하는 방식이다. **각 블록들은 포인터로 연결되기만 하면 되기에 단편화 현상이 발생하지 않는다**. 파일의 크기가 동적으로 증가하거나 하는 현상이 발생해도 포인터를 통해 추가만하면 되므로 유연하게 대응할 수 있다.
    
    하지만 무조건 **링크를 통해서 파일을 읽어야 하므로 속도가 느리다는 단점**을 갖고 중간에 **링크가 소실되기라도 하면 큰 문제가 발생**한다. 추가적으로 링크를 만들기 위한 포인터가 추가적인 오버헤드로 발생한다.
    

![[Pasted image 20231208180840.png]]

- **FAT**
    **연결할당의 문제점을 해결하기 위해 등장한 방법**이다. **FAT은 다음 블록으로 가는 포인터들만 모아서 만든 테이블을 블록에 저장**하는 방식이다. 이를 통해 연결 할당을 마치 연속 할당 처럼 사용하는 것이 가능해진다. 블럭을 접근하는 것도 링크를 탈 필요 없이 테이블의 값을 확인하면 된다. 또한 중간에 링크가 없어지더라도 FAT 테이블에 저장돼 있으므로 문제를 해결할 수 있다.

![[Pasted image 20231208180856.png]]

- **인덱스 할당**
    블럭 내에 테이블을 저장하지 않고 따로 인덱스 블럭을 활용해 해당 블럭에 다음 블럭 정보 테이블을 저장하는 방식을 말한다.

![[Pasted image 20231208180930.png]]