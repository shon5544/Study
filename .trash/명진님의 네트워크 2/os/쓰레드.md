### 출처
* https://stackoverflow.com/questions/8463741/how-linux-handles-threads-and-process-scheduling (프로세스와 스레드 스케줄링)
* https://hoony-gunputer.tistory.com/entry/Thread-Context-Switching-vs-Process-Context-Switching (쓰레드 스위칭)
* https://velog.io/@chanyoung1998/%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%A2%85%EB%A5%98%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4-%EC%8A%A4%EB%A0%88%EB%93%9C-OS-%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%9C%A0%EC%A0%80-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EB%A0%88%EB%93%9C (유저 영역, 커널 영역 스레드)
* https://stackoverflow.com/questions/28476456/threads-and-lwp-in-linux (lwp란)
* https://www.joinc.co.kr/w/Site/system_programing/Book_LSP/ch06_Signal (시그널 처리)
* https://www.joinc.co.kr/w/man/3/pthread_cancel (쓰레드 캔슬)
* https://ozt88.tistory.com/37 (쓰레드 스토리지)
___
### 개요
* [[#쓰레드란?]]
* [[#쓰레드의 속성]]
* [[#쓰레드의 스케줄링]]
* [[#커널 레벨 쓰레드(Kernel Level Thread)]]
* [[#사용자 레벨 쓰레드(User Level Thread)]]
* [[#커널 쓰레드 VS 사용자 쓰레드]]
* [[#커널 쓰레드와 유저 쓰레드의 연결]]
* [[#LWP]]
* [[#Thread Pool]]
* [[#Multithread fork() in Linux]]
* [[#시그널 처리]]
* [[#Thread Cancellation]]
* [[#TLS(Thread Local Stroage)]]
___
### 쓰레드란?

**쓰레드는 프로세스의 실행 단위이다. 이는 프로세스 내부에 존재하는 하나의 실행 흐름으로 복수개 존재하는 것도 가능하다.** 쓰레드는 하드웨어에도 존재하는데 일반적으로 1개의 코어가 1개의 실행흐름 (쓰레드)를 가질 수 있다. 하지만 근래에 들어서선 가상 스레드란 개념이 추가돼 한 코어에 2개의 쓰레드를 갖는다.

쓰레드를 활용하면 별개의 실행 흐름을 사용함으로써 **실행 단위를 잘게 쪼개 프로세스 전체가 블럭 당하는 현상을 막을 수 있다.** 예를 들어 한 프로세스 내에 연산과 IO가 동시에 존재하는 경우 IO가 발생하면 프로세스 전체가 블럭되버리는 현상이 발생한다.

이 경우 IO와 연산을 개별적인 실행 흐름으로 구성하면 **IO로 인해 블럭이 발생해도 하나의 실행 흐름이 블락될 뿐 프로세스 전체가 블럭되는 현상은 방지**할 수 있다. 이에 따라 CPU 효용성을 더욱 극대화 시킬 수 있게 된다.
___
### 쓰레드의 속성

**하나의 프로세스를 구성하는 쓰레드들은 스택과 PC(Program Counter)를 제외한 프로세스 메모리 자원(가상 메모리 공간)을 공유한다.** 따라서  쓰레드 간의 통신을 진행 할때는 공유하는 메모리 영역을 서로 접근하면 되므로 간편한 통신이 가능**하다. 하지만 하나의 자원을 여러 쓰레드가 공유하기 때문에 Race Condtion과 같은 문제가 발생**할 수도 있다.    

![[Pasted image 20231206195050.png]]

* **왜 스택과 PC는 따로 가지나요?**
쓰레드가 별개의 실행 흐름을 갖기 위해선 독자적인 함수 호출이 가능해야하고 이로 인해 스텍과 PC 값은 따로 할당 받는다.

<span class="red red-bg">쓰레드의 가장 큰 특징은 프로세스에 비해 가볍다는 점이다. 메모리를 공유하기 때문에 생성시 프로세스 만큼 큰 오버헤드가 발생하지 않고 스위칭 또한 프로세스 보다 가볍다.</span> 이에 따라서 메모리의 완벽한 분리가 필요한 경우가 아니고 실행 흐름을 늘려 병행 처리하는 것이 목적이라면, 프로세스를 fork하는 것보다 스레드를 생성하는 것이 더욱 효율적이다.

<u><b>또한 쓰레드는 프로세스와 달리 PID를 차지하지 않기 때문에 수에 있어서도 제약이 적은 편이다. </b></u> 그렇다고 제약이 없는 것은 아니다. 쓰레드 역시 메모리를 어느정도는 복사해야하기 때문에 수에 제약이 존재하는 편이다. 이에 따라 근래에는 싱글 스레드를 최대한 활용하는 방법들이 많이 대두되고 있기도 하다.
___
### 쓰레드의 스케줄링
 
**쓰레드는 프로세스와 마찬가지로 상태를 가지며 이에 따라 스케줄링 된다.** 스케줄링의 단위는 프로세스나 스레드이며 스케줄러는 둘의 상태를 확인 후 스위칭을 진행한다. <span class="red red-bg">이때 동일 프로세스에 존재하는 쓰레드 간의 스위칭은 일반적인 컨텍스트 스위칭에 비해 훨씬 경제적이다. </span> 프로세스 컨텍스트 스위칭이 발생했다면 페이지 테이블부터 힙, 데이터 등 모든 메모리 영역을 교체해야 했을 것이다.

> [!qutoe]
	> **Thread switching is very efficient and much cheaper because it involves switching out only identities and resources such as the program counter, registers and stack pointers.**

* **왜 쓰레드 스케줄링은 경제적인가요?**
Thread Control Block의 구조를 살펴보면 쓰레드의 스위칭이 효율적인 이유를 체감할 수 있다. TCB는 PCB 보다 구성요소가 적은데, **이는 Thread가  프로세스 메모리 영역을 모두 프로세스와 공유하기 때문이다.** 따라서 **프로세스와 달리 스레드는 스위칭시 페이지 테이블, 캐시 등 메모리와 관련된 영역까지 전부 변경하지 않아도 된다.** (PCB 교체와 TCB 교체의 차이)
![[Pasted image 20231206205109.png]]

> [!info]
> **동일 프로세스에 위치한 쓰레드들은 가상 메모리 공간을 그대로 사용하기 때문에 스위칭이 저렴하다.**

___
### 커널 레벨 쓰레드 (Kernel Level Thread)

<span class="red red-bg">커널 레벨 스레드는 운영체제가 지원하는 스레드로 커널이 스레드를 관리하는 주체이다.실질적으로 CPU에서 실행되는 단위이다.</span> 생성, 스케줄링 작업을 모두 커널이 수행하며사용자 레벨 스레드와 달리 스케줄러가 각 스레드 단위로 스케줄링을 실시하기 때문에 단일 스레드의 블락이 전체 프로세스를 블락 시키진 않는다. 

<b><u>프로세스가 실행되기 위해선 반드시 커널 스레드를 할당 받아야 한다.</u></b>

![[Pasted image 20231206215006.png]]
___

### 사용자 레벨 쓰레드(User Level Thread)

**사용자 레벨 쓰레드는 커널영역의 상위 사용자 영역에 존재하는 쓰레드로 주로 라이브러리를 통해 지원**된다. 라이브러리는 쓰레드의 생성, 삭제 기능을 제공하며 사용자는 이를 활용해 프로세스 내부에 스레드를 생성할 수 있다.  

반면 <b><u>커널은 해당 쓰레드의 존재를 인지하지 못하며 하나의 싱글 프로세스로 취급한다.</u></b> 따라서 <span class="red red-bg">유저 레벨 쓰레드 스위칭시 모드의 전환이 필요 없고 하나의 프로세스에 존재하는 쓰레드들이기 때문에 스위칭 비용이 저렴하다. </span>

<b><u>스케줄러는 개별 사용자 스레드의 존재를 모르고 하나의 프로세스로만 인식 하기 때문에 사용자 스레드 중 하나만 블락 되더라도 프로세스가 블락되면서 프로세스를 블락으로 판단해 전체 스레드가 멈추는 현상이 발생할 수도 있다.</b></u>(연결된 커널 스레드가 1개인 경우) 이 경우 실행 흐름의 블락을 막겠다는 쓰레드의 기본적인 취지를 무시하게 된다.

![[Pasted image 20231206215211.png]]
___
### 커널 쓰레드 VS 사용자 쓰레드

* **사용자 쓰레드**
사용자 쓰레드는 사용자 영역에 위치하며 스위칭 비용이 저렴하다. 또한 생성과 해제가 간단한 편이다. 하지만 커널의 스케줄러가 개별 스레드를 인식하지 못해 프로세스 단위로 블락킹이 발생할 수 있다. 

* **커널 쓰레드**
커널 쓰레드는 커널에서 제공해주기에 안정성 있고 다양한 기능이 존재하지만, 모드 전환으로 인한 오버헤드가 존재한다. 또한 사용자가 자유롭게 생성 및 삭제를 하는데 어려움이 존재한다.
___
### 커널 쓰레드와 유저 쓰레드의 연결

<span class="red red-bg">스케줄러가 인식하는 것은 커널 쓰레드 뿐이기 때문에 유저 쓰레드는 커널 쓰레드와 연결돼어야만 CPU를 할당 받아 실행이 가능하다.</span> 따라서 유저 쓰레드를 커널 쓰레드와 연결해줘야 하는데 이때 연결 형태에 따라 장단점이 다르다.

* **N:1 모델**
![[Pasted image 20231207105614.png]]

여러 개의 유저 쓰레드가 한 개의 커널  쓰레드에 연결되는 형태를 말한다. 이 경우 한 개의 쓰레드가 블락되면 연결된 커널 쓰레드까지 블락되면서 프로세스 전체가 블락된다. **실제로 실행되는 것은 한개의 스레드이기 때문에 병행성을 활용하지 못하는 방법**이다.

* **1:1 모델**
![[Pasted image 20231207110006.png]]
**사용자 레벨 쓰레드가 각각 하나의 커널 쓰레드와 연결되는 형태**로 각 사용자 쓰레드는 서로에게 영향을 끼치지 않는다. 스케줄링을 OS에 전적으로 위임해 유저는 쓰레드의 동작 순서를 명확히 파악할 수 없다. **각 쓰레드가 동시에 스케줄링되므로 멀티 코어 환경일 경우 여러 쓰레드가 동시에 실행될 수 있다.** 리눅스가 채택하고 있는 모델이 이 방식이다.

* **N:M 모델 (N > M)** 
여러 개의 사용자 레벨 쓰레드가 그 보다 적은 복수 개의 커널 쓰레드에 매핑되는 방식이다. 1:1과 1:N의 장점을 섞은 방식으로 많은 수의 쓰레드 생성으로 인한 오버헤드는 줄이고 병행성은 높인 방식이다.
![[Pasted image 20231207111844.png]]

>[!info]
>요즘 트렌드는 1:1이라고 한다. ios도 1:1로 동작한다.

___
### LWP

**LWP(Light Weight Process)는 가벼운 프로세스로 사용자 쓰레드를 커널 쓰레드가 인식할 수 있게 하기 위해 사용하는 자료구조**이다. 커널 쓰레드는 프로세스만을 인식하고 각각의 유저 쓰레드를 구분할 수 없다. 이에 따라 **유저 쓰레드를 커널에게 인지시키기 위해 쓰레드를 프로세스의 형태로 포팅할 필요가 존재했는데 이때 사용하는 구조가 LWP**이다. 

![[Pasted image 20231207114611.png]]

가벼운 프로세스인 이유는 **LWP가 TCB를 활용해 구성되기 때문이다. 따라서 일반적인 프로세스에 비해 메모리 영역의 크기가 훨씬 작고 이에 따라 가벼운 프로세스**라고 부르게 된것이다. **LWP는 실질적으로는 유저레벨 쓰레드를 표시한다 볼 수 있기 때문에 LWP와 유저 쓰레드를 동일하게 취급하는 경우도 존재한다.**
___
### Thread Pool

**쓰레드 풀은 DB 연결시 사용하는 커넥션 풀과 마찬가지로 쓰레드들을 미리 생성해 둔 뒤 할당 해주는 방식을 의미한다.** 쓰레드를 요청하면 풀에서 쓰레드를 추출해 전달해주고 전부 사용한 후에는 쓰레드를 풀에 반납한다. 이러한 쓰레드 풀을 활용하면 <b><u>생성되는 쓰레드의 수를 제한할 수 있고 쓰레드를 생성하는 것에 비해 더 빠른 할당이 가능하다.</b></u>

**쓰레드 풀을 잘 사용하고 싶다면 각 쓰레드가 담당하는 테스크의 성질이 비슷하고 서로 독립적이여야 한다. 만약 쓰레드 별 소요시간이 전부 다르거나 종속적인 관계를 띈다면 병목 현상이 발생할 수 있기 때문이다.**
___
### Multithread fork() in Linux

멀티 스레드에서 fork()를 실행할 경우 리눅스는 해당 프로세스 내부의 모든 쓰레드를 복사하진 않는다. fork()를 호출한 쓰레드를 복사해 단일 쓰레드를 갖는 프로세스를 생성한다.

>[!quote]
> **A process shall be created with a single thread**. If a multi-threaded process calls fork(), the **new process shall contain a replica of the calling thread and its entire address space, possibly including the states of mutexes and other resources.** Consequently, to avoid errors, the child process may only execute async-signal-safe operations until such time as one of the exec functions is called.

___
### 시그널 처리

**시그널은 프로세스에게 어떤 사건이 발생했음을 알리기 위해 사용한다.** 시그널은 가장 기본적인 의사전달 수단중 하나로 직관적인 의사 전달이 가능하다. **시그널은 주로 비동기적인 사건에 대한 알림을 받거나 사건을 동기화 하기 위해 사용한다.** (전화 알림, 경주 휘슬)

**시그널은 특정 사건이 발생했을 때 생성되며 프로세스에게 전달된다. 이때 전달된 시그널은 반드시 처리돼야 한다.**  운영체제가 처리하는 대표적인 시그널은 [[시스템 콜#Interrupt|Interrupt]]가 있다. 시그널을 처리는 방법으로는 등록된 함수를 호출하거나, 시그널을 무시하거나, 시그널을 수신하고 아무런 행동을 안하는 방법등이 있다.

**인터럽트가 인터럽트 루틴에 의해 처리 되듯 시그널 또한 시그널을 처리하기 위한 시그널 핸들러가 존재한다. 이는 기본적으로도 존재하고 사용자가 직접 정의해 사용할 수도 있다**. [[동기와 비동기 (Blocking, None-Blocking)#Signal and Call Back|Call Back]]에서 시그널을 받아 콜백을 처리하는 함수가 대표적인 예시이다.

**시그널의 대표적인 예시로 Ctrl + C가 있는데 이를 호출 할 경우 Kill 시그널이 프로세스에게 전달돼 프로세스가 죽게된다. kill 명령어도 동일한 방식으로 동작한다.**
___
### Thread Cancellation

pthread_cancel은 쓰레드를 종료하기 위해 사용할 수 있다. 종료 요청을 받은 쓰레드는 매개변수에 따라 다르게 동작하는데 곧장 종료 되거나 종료가 가능한 시점에서 종료할 수 있다. 

<b><u>쓰레드가 종료 요청을 받았다면, 해당 쓰레드는 pthread_exit(PTHREAD_CANCELED)를 수행한다. 또한 모든 cleanup handler가 수행돼며, thread-specific 데이터를 호출하고 쓰레드가 종료된다. </u></b>종료시 리턴되는 값은 PTHREAD_CANCELED이다. 
___
### TLS(Thread Local Stroage)

쓰레드는 가상 주소 공간을 공유하고 스택 영역만 구분해서 사용하기 때문에 쓰레드에서 전역 변수를 사용하는 것은 큰 제약이 존재한다. 이에 따라 <span class="red red-bg">쓰레드에서도 전역 변수를 사용할 수 있게 하는 각 쓰레드만의 전역 변수 공간에 대한 필요성이 발생했는데, 이 공간이 바로 TLS이다. </span> TLS는 쓰레드만의 저장공간을 만들어주는 기법으로 이를 사용하면 스택 영역이 아닌 데이터 영역에 개별 쓰레드만의 데이터를 저장하는 것이 가능하다. (static과 흡사하다)

![[Pasted image 20231207133231.png]]
