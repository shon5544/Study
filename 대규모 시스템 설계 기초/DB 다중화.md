
## DB 다중화(클러스터링)
DB 서버 사이에 주(Master), 부(Slave)를 설정하여 데이터 원본은 주 서버에, 사본을 부 서버에 저장하는 방식이다. 부 서버는 여러 개가 될 수 있다.

각 서버들의 역할을 알아보자. 
- 주 서버: 쓰기 연산만 지원한다. 만약 부 서버가 죽는다면 읽기 연산도 처리한다.
- 부 서버: 읽기 연산만 지원한다.

간단하고 명료한 역할 분배다. 이러면 대체 뭐가 좋을까?

대부분의 상황에서는 아마도 읽기 비중이 훨씬 많을 것이다. 컨텐츠를 퍼블리싱하는 사람들보다는 컨슘하는 사람들이 더 많은게 일반적이다. 만약에 사람들이 굉장히 많이 늘어난다고 했을 때, DB가 하나면 어떤 일이 일어날지 한번 생각해보자.

이 상황에서는 한 DB가 읽기(심지어 많은 양의)와 쓰기 연산 모두를 책임져야한다. 아무리 DB 서버가 슈퍼맨이라도 어떤 임계점을 넘어서면 죽어버릴 수도 있다.

그러나 DB 다중화를 한다면? 읽기 연산은 적절히 분산 처리되고 쓰기 연산은 많이 부담스럽지 않으니(적어도 읽기보다는) 우아하게 많은 연산량을 지원할 수 있다. 이것도 일종의 수평 확장이라고 볼 수 있을 것이다.

## 읽기 연산은 어떻게 분산 처리 될까?
이 방법은 시스템마다 다를 수 있다. 

크게 **코드 레벨에서 처리하는 방법**과 **자동 분산 기능을 사용하는 방법**이 있다.

**코드 레벨에서 처리하는 방법**은 단순 무식하다. 읽기 쿼리는 부 서버 엔드포인트에 보내고, 쓰기 쿼리의 경우 주 서버 엔드포인트로 보내도록 만들면 된다. 스프링 같은걸로 개발하면 어떻게 해야할지 숨이 턱 막힐 수 있는데 AbstractRoutingDataSource로 라우팅하는 로직을 만들면 된다. AOP로 구현은 어렵지 않게 가능할 것이다.

**자동 분산 기능을 이용하는 방법**은 이를 지원하는 서비스에서 알아서 해주는 것이다. 적절히 요청을 처리해주는 일종의 로드 밸런싱 역할을 하는 게 있다.

언급했듯 자동 분산 기능은 시스템마다 지원하는 경우도 있고 아닌 경우도 있다. Amazon Aurora 같은 넘은 자동 분산을 지원한다. AuroraReader Endpoint라는 단일 엔드포인트를 지원한다. 그니까 부 서버들의 엔드포인트들을 하나로 모아주는 엔드포인트다. 여기에 읽기 쿼리 보내면 알아서 부 서버들 중 하나에게 쿼리를 요청한다. 만약 RDS 였으면 읽기 엔드포인트들을 다 등록해서 라우팅을 해야할 것이다.

이를 통해 만약 부 서버(읽기 서버)가 많아지면 Aurora를 쓰고, 그게 아니라면 RDS를 쓰는게(가격 측면에서) 더 좋은 선택일 것임을 알 수 있다.
