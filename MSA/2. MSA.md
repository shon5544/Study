

## 왜 지금에서야...?
- 일반적으로는 클라우드라는 개념 자체가 별로 없었음.
- IDC를 사용하는게 너무나 당연한 문화이고 많은 SI 업체들이 이렇게 사용했음
- 모놀리식 환경에서의 개발 노하우들을 쉽게 버리고, 새로운 것을 받아들이기가 쉽지는 않았다.
- 무엇보다 많은 서버들에 다양한 서비스를 배포한다라는 개념은 굉장한 리소스를 수반한다고 생각했었음.

## AWS의 등장
- AWS에서는 다양한 IaaS, PaaS, SaaS를 제공함.
- EC2가 가장 대표적임.
- 이게 등장하면서 클라우드 서비스가 대중화되기 시작함.
- 인프라와 서버를 구축하는 과정이 굉장히 큰 리소스가 들었기 때문에 이를 간소화할 수 있는 서비스는 그야말로 혁신이었음.
- 거기에 클라우드 기술 스택들의 발전까지도.....
	- docker
	- docker compose
	- kubernetes
	- etc...

결론적으로, 이러한 서비스들의 등장으로 인프라, 서버 구축 과정의 리소스를 굉장히 단축시킬 수 있었음.
=> MSA하기 매우 쉬워짐(이전에 비해)

## 모놀리식 아키텍처 / SOA (Service Oriented Architecture)
- 처음 소프트웨어 아키텍처의 시작은 모놀리식이었음.
- 그리고 여기서 오는 고통들과 제한적인 환경에서나마 해결하고자 했던 노력에서 나온 아키텍처가 SOA

### 모놀리식
- 하나의 어플리케이션이 하나의 서버에 배포
- 단일 코드베이스
- 싱글 / 멀티 모듈 방식으로 개발은 가능하지만, 근본적으로 하나의 프로세스

### SOA
- 명확하게 `아 이건 SOA다`. 라고 구분할 수 있는 특징은 없음. 다소 모호함.
	- 커뮤니티마다 SOA에 대한 구분이 묘하게 다름
- "서비스" 단위로 개발하고, 서비스 간 규격화된 프로토콜(인터페이스)를 사용하여 통신.
- 대개 동일한 기술 스택들을 가지고 서비스들을 개발하며 각 서비스들간의 재사용이 목적.
- ESB(Enterprise Service Bus)라는 개념을 통해, 요청에 대해 어떤 서비스들을 호출할 지 캡슐화 된 Layer가 존재.
- **서비스 간 통합**을 강조

### 둘의 공통점
- Shared DB 사용
- 대개 원 코드베이스
- 모듈 / 서비스 간 규격화된 호출 방식을 사용 (서비스 간 통합 관점)
	- 모듈 / 서비스 간 강한 의존성, 결합도

### SOA만의 특징, 차이점
![[Pasted image 20240403022247.png]]
- 서비스들이 독립적으로 배포 가능
- 비즈니스 로직에 따라 어떤 서비스를 호출할 지 결정하는 Layer가 존재
- 트랜잭션 구현은 별개로 해야 함.
- ESB의 관리
	- MSA의 원칙을 정면으로 반박
- 동일 플랫폼(ex: JVM)에서 서비스 간 호출을 하다보니 성능 이슈 존재
	- 왜? 결국 ESB가 필요함.
	- ESB가 있는 한 결국 Integration Monolith에 불과함.

## SOA, MSA
![[Pasted image 20240403022947.png]]

### 공통점
- 개발의 단위를 **서비스**로 인지
- 다른 서비스와 독립적으로 개발, 배포 가능

### MSA만의 특징, 차이점
- 비즈니스 로직(서비스)의 재사용 지양
	- 서비스 간 결합도를 낮추는 것이 목표
- 낮은 결합도로 변화에 애자일한 대응 가능
- 각 서비스는 각 서비스의 특성에 맞는 최적의 기술스택을 독립적으로 선택 가능
- 서비스 간 자유로운 방식으로 통신 가능
	- HTTP, gRPC...

## MSA 원칙

### 그래서 모놀리식과 SOA의 문제?
- **요구 사항 변화에 따른 빠른 대처**가 어려움.

### 어떻게 개발하길래 이렇게 빨라질 수 있나?
- 모놀리식 환경에서는 비교적 필요성이 크지 않았던 것들
	- CI/CD Pipeline, Automation, API Gateway...
- 이러한 인프라 요소 정말 적극적으로 사용하기 때문에 빠르게 개발할 수 있음.
- 저것들은 모놀리식 환경에선 비교적 필요성이 크지 않다.

