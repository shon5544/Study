
## 모놀리틱
- 단일 기기에 단일 어플리케이션으로 모든 서비스를 구성하는 것.

**모놀리틱 특:**
- 일단 만들기 쉬움.
- 모든 서비스가 하나의 DB endpoint를 사용.
- 단 한줄 코드 변경이 일어나면 재배포해야함.
	- 뭔 말이냐면 결제 시스템만 수정됐는데 이걸 따로 업데이트를 못하고 모두 다같이 업데이트 해야됨.
	- 구조 특성상 어쩔 수 없는거임.
- 싱글 혹은 멀티 모듈로 구성할 수는 있음. 다만 CI의 단위가 달라질 뿐이다. CD의 범위는 여전히 전체.

## 모놀리틱이 일반적이었던 이유
### 일단 쉬움.
- 개발하고 빌드하고 나온 걸 그대로 올려서 실행시키면 됨

### 고려할게 많지 않음
- 서버 리소스의 효율적인 활용이 가능함

### IDC가 일반적이었음
> 💡 IDC = 온 프레미스 환경 서버
- IDC가 일반적이었음. 서버란 굉장히 비싼 자원이었다.
- HVAC(항온 항습) 해주는 사람이 항상 필요함

## 모놀리스 개발 배포 프로세스
- 개발 -> 빌드 -> 배포의 순서대로.
- 개발 특: 
	- 적당히 프레임워크 이용해서 개발. 복잡한건 프레임워크가 다 해줬기 떄문에 인력 구하기 쉬웠음.
- 빌드 특: 
	- 공통 모듈 수정할 땐 타 팀 코드에 대해 디펜던시가 있었음. 조심해야해서 어렵다.
- 배포 특:
	- 특별히 신경쓸만한 부분이 없었음.
	- 1주일에 1번 배포되는 식으로 굴러감
	- 자주 배포가 되지 않다보니까 Graceful, Warm up이 어려움

## 모놀리스의 종류

### 싱글 모듈과 멀티 모듈
- 모놀리식 아키텍처에서 모듈을 구성하는 방식 차이임.

### 싱글 모듈
- 모든 소스가 단일 모듈 내에 존재
- 응집성과 결합도가 매우 높음.
	- 공통 데이터에 대한 코드 사용이 쉬움.
	- 대신 사이드 이펙트가 있을 수 있음.
- 설계 / 구현이 간단하고 단순.
- 최상위 싱글 패키지.
- 유연성, 확장성이 제한적임.

### 멀티 모듈
- 역할, 서비스 별로 모듈화 되어 있음
- 응집성과 결합도가 낮은 편
	- 공통 데이터에 대한 코드 사용이 어려울 수 있음
	- 대신 사이드 이펙트가 적음
- 모듈간 인터페이스 정의 필요
	- 아키텍처와도 밀접한 관련
- 최상위 멀티 패키지
- 유연성, 확장성이 비교적 좋음.

## 싱글 모듈 배포 방식
- 우리가 흔하게 하는 방식
- gradle을 이용한 jar 파일 결과가 하나 나옴.
- 그거 배폴

## 멀티 모듈 배포 방식
- 각각의 모듈마다 따로 jar가 생성됨.
- 모듈간 공유하고 있는 common 패키지는 모든 모듈에 대한 전역적인 의존성을 가지고 있기 때문에 사이드 이펙트에 취약함.
- 결국엔 모놀리스라는 한계가 있는 거임.

## 모놀리스의 장점을 자세히 알아보자
- 쉽고 간단함.
	- 비교 예시를 들어보자.
	- MSA에서 트랜잭션을 구현하려면 어려움. 
	- 그러나 모놀리스에서는 그냥 쉽게할 수 있음.
	- 그래서 크게 고급 개발자가 필요하진 않음
- 배포도 간단하다.
- 어디서 패키징해도 상관 없고, 어떻게든 배포만 하면 된다.
	- 지속적 통합, 지속적 배포가 모놀리스에서는 그렇게 중요하지는 않기 때문
- 유지 보수가 비교적 쉽다.
- 비싼 서버 리소스를 최적화해서 사용이 가능하다.
- 공통 모듈 등을 활용하기가 매우 쉽다.

## 모놀리식 아키텍처가 유용할 수 있는 케이스
- 창업 혹은 새로운 서비스를 시작하는 경우
- 소수의 팀원으로 빠르게 오픈해야하는 경우
- 클라우드 환경을 사용하기 어려운 경우
- 금융 등 보안과 안정성이 최고로 중요한 경우
- 개발자들의 역량이 비교적 낮을 경우
- DevOps 등 전문 인력이 부족할 경우
	- CI/CD 파이프라인 등의 구축이 어려울 경우
**빨리빨리**가 중요한 프로젝트의 경우 MSA보다 모놀리스가 훨씬 나을 수도 있음.

## 모놀리스 아키텍처의 단점
- Scale Out이 너무 어렵다.
	- 단일 DB에 대한 의존성이 너무 크다
	- 사실 어플리케이션 자체에 대한 Scale Out은 어려운게 아님.
	- 근데 각 인스턴스들이 하나의 DB를 참조하게 될 것이다.
	- 왜? 모놀리식이란 결국 하나의 어플리케이션을 의미하는 것이니까.
	- 그럼 하나의 DB를 참조하게 될 텐데 그렇다면 어플리케이션을 Scale Out해도 DB가 받는 부하는 똑같다는 말이다.
	- 관계형 DB 특이 뭐냐, Scale Out이 어려운거잖아. 그게 이제 모놀리스 어플리케이션에게도 전파되는 거다.
	- 이게 멀티 모듈에도 적용되는 말인지도 고민을 해보자. 
	- 직접 경험해본 멀티 모듈 환경에서는 각 모듈간 다른 DB 커넥션을 줄 수 있었기 때문이다.
- 모놀리식 환경이 보편화되고, 시스템이 커질 수록 커뮤니케이션 코스트가 기하급수적으로 늘어난다.
- 규모가 커질 수록, 복잡성이 증가하여 수정에 대한 부담이 증가
- 대규모 어플리케이션 환경에서는 단순한 수정 사항일지라도, 배포까지 시간이 오래걸릴 수 있다.
- **장애 시, 전체 어플리케이션에 영향을 크게 받게된다.**

## 모놀리식이 단점이 될 수 있는 경우
> 반대로 이야기하면 MSA를 쓰는게 장점일 경우이다.

- MSA, Cloud 환경에 충분히 숙련된 개발자들이 많은 경우
- 많은 서비스가 식별이 되어 동시 다발적으로 개발을 진행하는 경우
- 보안과 안정성보다는 빠른 기능 개발과 배포가 중요한 서비스
	- 여기서의 **빠른 기능 개발**이란 창업 같은 느낌의 0부터 만드는 것이 아니다.
	- "아 이런 기능이 있었으면 좋겠어요"같은 추가 feature에 대한 이야기다.
	- 모놀리식은 여러 기능간 디펜던시가 있기 때문에 빠른 기능 개발이 어려울 수도 있다.
- Devops 등 전문 인력이 충분하고, 개발자들이 CI/CD 파이프라인에 대해서 어느정도 이해가 있는 경우.