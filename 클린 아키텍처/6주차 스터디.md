
## 11장: 의식적으로 지름길 사용하기
### 왜? 지름길은 깨진 창문 같을까?
> 💡 깨진 창문 이론: 
> 멈추거나 망가져 보이거나 관리되지 않는다고 여겨지면 인간의 뇌는 더 멈추고 망가뜨리고 싶어진다고 느낀다.
- 기물 파손이 흔한 동네에서는 방치된 차를 도둑질하거나 망가뜨리는 일이 더 쉽게 일어난다.
- '좋은' 동네라도 차의 창문이 깨져있다면 차를 망가뜨리는 일이 쉽게 일어난다.
- ...etc

same with:
- 품질이 떨어진 코드에서 작업할 떄 더 낮은 품지르이 코드를 추가하기 쉽다.
- 코딩 규칙을 많이 어긴 코드에서 작업할 때 또다른 규칙을 어기기도 쉽다.
- 지름길을 많이 사용한 코드에서 작업할 때 또 다른 지름길을 추가하기도 쉽다.

### 깨끗한 상태로 시작할 책임
소프트웨어 프로젝트는 대개 큰 비용이 들고 장기적인 노력을 필요로 하기 때문에 깨진 창문을 막는 것이 소프트웨어 개발자들의 아주 막대한 책임이다. 그렇기에 깨진 창문 없이 깔끔하게 시작하여 막도록 노력해야한다는 얘기를 하는거다.

그러나 때때로 지름길을 취하는 것이 더 실용적일 때도 있는데: 
- 작업 중인 부분이 프로젝트 전체로 봤을 때 그리 중요하지 않음.
- 프로토타이핑 작업 중
- 경제적인 이유
이러한 이유들 때문이다.

이럴 때 사용하는 의도적인 지름길에 대해서는 세심하게 잘 기록해야한다. 마이클 나이가드가 제안한 아키텍처 결정 기록(ADRs)의 형태도 괜찮다.

어쨌든 간에 우린 미래의 우리 혹은 프로젝트 인계받는 이들에게 빚을 지고 있는 것이다. 만약 팀원 모두가 이 문서에 대해 인지한다면 지름길이 합리적인 이유에 의해 의도적으로 추가됐다는 사실을 알기에 깨진 창문의 영향을 더 줄일 수 있을 것이고, 결과적으로는 기술부채를 줄이는 것에 기여할 것이다.

위의 언급 사안을 잘 기억하고, 헥사고날에서 어떤 지름길들을 만들 수 있는지 몇가지 이야기 해보자.

### 유스케이스 간 모델 공유
여러 유스케이스들의 입력 모델이 같이 쓰이면 어떻게 될까? 해당 유스케이스들이 강결합된다는 것이다. 
그런데 이 유스케이스들이 기능적으로 묶여 있는 상황을 감안해보자. 굳이 유스케이스들이 강결합된다고 해도 큰 문제가 있을까?

어차피 입출력 모델이 바뀔 시 둘 다 똑같이 바뀌어야하는 유스케이스라면 묶이더라도 상관이 없다. '변경될 이유'가 같은 상황이라면 말이다.

그러나 조심해야한다. 비슷한 개념의 유스케이스 여러 개를 만들 때 유스케이스가 **결국**엔 독립적으로 진화해야한다면, 입력 모델을 공유했을 시 이건 `지름길`이 된다.

따라서 유스케이스들이 독립적으로 진화할 필요가 있는지 주기적으로 질문해야한다. 대답이 "예"가 된다면 그 때가 입출력 모델을 분리해야할 때다.

### 도메인 엔티티를 입출력 모델로 사용하기
도메인 엔티티를 입출력 모델로 쓰고 싶을 수 있다.

그렇게 쓴다고 가정했을 때, 인커밍 포트는 도메인 엔티티에 의존성을 가진다. 그 결과, 도메인 엔티티는 변경되어야할 이유가 또 생긴다.

근데 도메인 엔티티가 `의존하는`게 아니라 `의존받는` 건데, 어떻게 엔티티를 변경해야할 이유가 된다는 것일까?

도메인 엔티티에는 존재하지 않는 정보를 유스케이스가 필요로 한다고 생각해보자. 이 정보는 최종적으로 도메인 엔티티에 저장돼 있어야 하는 것이 아니라 다른 도메인이나 다른 바운디드 컨텍스트에 저장되거나 할 것이다. 그럼에도 불구하고 이미 유스케이스 인터페이스에서 사용할 수 있기 때문에 도메인 엔티티에 새로운 필드를 추가하고 싶다는 생각이 든다.

간단한 생성이나 업데이트 유스케이스에선 유스케이스 인터페이스에 도메인 엔티티가 있는 것이 괜찮을지도 모른다. 데이터베이스에 저장해야하는 바로 그 상태 정보가 엔티티에 있기 때문이다.

그러나 유스케이스가 단순히 데이터베이스의 필드 몇개를 업데이트하는 수준이 아니라 더 복잡한 도메인 로직을 구현해야한다면 유스케이스 인터페이스에 대한 전용 입출력 모델을 만들어야한다.

왜냐? 유스케이스의 변경이 도메인 엔티티까지 전파되길 바라진 않을 것이기 때문이다.

이 지름길은 위험하다고 한다. 그 이유는 많은 유스케이스가 간단한 생성, 업데이트 유스케이스로 시작해서 시간이 지나며 복잡한 도메인 로직 괴물이 되어간다는 사실 탓이다.

최소 기능 제품으로 시작해서 점점 복잡도를 높여가는 애자일 환경에서 특히 그렇다. 그러므로 처음에는 도메인 엔티티를 입력 모델로 사용했더라도 도메인 모델로부터 독립적인 전용 입력 모델로 교체해야하는 시점을 잘 파악하도록 하자.

### 인커밍 포트 건너뛰기
인커밍 포트는 의존성이 안쪽을 향하는 것에 있어서는 필수 요소가 아니다. 
이를 제거하는 것으로 추상화 계층을 줄일 수 있는데, 이게 보통은 괜찮게 느껴질 것이다.

하지만 인커밍 포트는 애플리케이션 중심에 접근하는 진입점을 정의한다. 이게 없으면 특정 유스케이스를 구현하기 위해 어떤 서비스 메서드를 호출할지 알아내기 위해 애플리케이션 내부 동작에 대해 더 잘 알아야한다. 전용 인커밍 포트를 유지하면 한눈에 진입점을 식별할 수 있다.

근데 여기서부터는 내 사견이지만, 서비스를 특정 유스케이스에 따라 세분화하고 분리를 철저히하면 이는 해결될 수 있는 문제가 아닐까? 추상화를 하지 않고도 서비스를 세분화하는 것으로 특정 유스케이스에 대한 진입점을 식별할 수 있다. 좀 더 고민해보면 좋을 사안일 듯하다.

물론 이것뿐은 아니고 이점이 더 있긴 하다. 인커밍 포트를 유지함으로써 아키텍처를 쉽게 강제할 수 있기 때문이다. 아키텍처를 강제하는 옵션들을 통해 어댑터에서는 포트만 호출하도록 할 수도 있는데 이는 애플리케이션 계층에 대한 모든 진입점을 정의하는 매우 의식적인 결정이 된다고 한다.

애플리케이션 규모가 적거나 or 인커밍 어댑터가 하나밖에 없어서 모든 제어 흐름을 포트 없이 파악할 수 있다면 인커밍 포트는 없는게 더 편하다. 그러나 애플리케이션의 규모가 이후로도 계속 작게 유지되거나 인커밍 어댑터가 계속 하나밖에 없을 것이라고 확신할 수 있을까?

#### 내 생각
흠. 나는 솔직히 모르곘다. 책에서는 이 포트 건너뛰기에 대해서 부정적으로 바라보고 있는 것 같은데 내 생각은 다르다.

우선 `특정 유스케이스에 대한 진입점을 식별한다`? 위에서 내가 얘기했듯 서비스를 특정 유스케이스 별로 특별히 세분화한다면 굳이 이 식별자가 인터페이스가 아니더라도 된다. 서비스 만으로도 충분히 파악할 수 있다는 것이다.

`아키텍처를 강제하기 쉽다`라는 이점은 이해하고 공감하지만, 지지하지는 않는다. 추상화 계층을 통해 유스케이스 진입점을 명시화하고 있다면 이는 당연히 도움이 되는 이야기다. 그러나 핵심은 이 명시화가 굳이 추상화 계층을 만들지 않더라도 가능하다는 점이다. 

책에서 이야기 하듯이 모든 제어 흐름을 포트 없이 파악할 수 있다면 인커밍 포트는 없는게 더 편하다. 애초에 포트가 없어도 서비스 세분화로 유스케이스 진입 구분이 가능한데, 굳이 그래야할까?

특히 객체지향적으로 개발하기 위해 애플리케이션 서비스가 도메인 엔티티/서비스들의 파사드 역할만을 하고, 유스케이스별 세분화가 되어있다면 추상화 계층을 거치는 것은 더욱 불편하기만 할 것이다.

인커밍 포트가 없다고 애플리케이션 코어에 대한 의존성 방향이 달라지는 것은 아니므로 솔직히 잘 모르겠다. 나라면 인커밍 포트는 딱히 두지 않고 개발할 것 같다.

### 애플리케이션 서비스 건너뛰기
정말 단순한 유스케이스의 경우 그냥 애플리케이션 서비스를 건너뛰고 싶을 수 있다.

간단한 CRUD 유스케이스라면 정말 구미가 당기는 방법일 수 있다. 그대로 전달하는 대신 영속성 어댑터가 직접 유스케이스를 구현하도록 할 수 있다.

애플리케이션 코어에는 유스케이스라고 할 만한 것이 없어진다. 만약 시간이 지나면서 점점 유스케이스가 복잡해지면 도메인 로직을 그대로 아웃고잉 어댑터에 넣고 싶어질 수 있다. 유스케이스가 어댑터에 있으니 그러고 싶어지는 것이다.

이러면 도메인 로직이 분산되어서 유지보수하기 당연히 힘들 것이다.

진짜 간단한 CRUD 케이스에서는 애플리케이션 서비스를 건너뛰기로 결정할 수도 있다. 그러나 더 많은 책임이 생겨난다면 곤란해질 것이다. 그럴 경우 `애플리케이션 서비스를 만든다` 같은 명확한 가이드라인을 팀에 정해둬야한다.

#### 내 생각
내 생각에 이 지름길은 굉장히 별로다.
계층간 책임과 역할을 정했다면 정말 간단하더라도 계층을 건너뛰거나해서는 안 된다.

왜? 내가 생각하는 이유는 크게 두 가지다:
- 아까 위에서 나왔듯 유스케이스가 커진다면 도메인 로직의 응집이 흩어질 가능성이 있다.
- 일관성 없는 의존성 흐름은 프로젝트 파악과 유지보수, 협업을 힘들게 할 것이다.

만약 도메인 로직의 응집이 흩어지는 것과, 일관성 없는 의존성 흐름이 생기는 것은 정말 끔찍한 일을 만들게 될 것이다. 그런 엉망진창인 프로젝트를 유지보수 해본다고 생각해보자. 도메인 로직이 어딨는지 찾고는 힘들어지고 코드의 어떤 부분은 어디를 참조하면 될 지 훤히 보이는데 특정 부분은 어디로 가야할지 잘 모르게 될 것이다. 그렇다면 이 도메인 로직을 사용하는 계층으로 가서 IDE의 도움을 받아 해당 로직의 구현부로 가고 거기서 유지보수를 하고... 나중에 다시 유지보수를 해야하는데 이 흐름이 명확하지 않아서 또 헷갈리고, 새로 인수인계 받을 사람이 왔는데 어디서부터 어떻게 설명해야할지 난감해지고.....

물론 책에서는 애플리케이션 서비스만 건너뛰는 이야기를 했지만, 나는 깨진 유리창 이론을 꽤나 신뢰한다. 여기서 구멍이 크게 났다면 이렇게 난잡하게 만들 특별한 당위가 없지 않는 이상 비슷한 실수를 만들게 될 가능성이 있다. 적어도 나는 그렇게 생각한다.

때문에, 다시 한번 굳이 언급하지만 계층간 책임과 역할을 정했다면 정말 간단하더라도 계층을 건너뛰면 안 된다고 생각한다고 강조해본다.

## 12장: 아키텍처 스타일 정하기
### 도메인이 왕이다.
지금까지의 스터디를 통해 헥사고날의 주요 특징이 영속성 관심사, 외부 시스템에 대한 의존등의 변화로부터 자유로운 도메인 코드를 작성할 수 있는 점이라는게 명확히 보였던 것 같다.

이는 헥사고날의 가장 중요한 가치이기도 하다. 또한 이게 DDD와 어울리는 이유이기도 하다. DDD에서는 도메인이 개발을 주도하기 때문에. 영속성 문제나 다른 기술 측면에 대해 함께 생각할 필요가 없게 되면 도메인에 대해 가장 잘 고려할 수 있게된다.

책에서는 도메인 코드를 향한 의존성을 역전시키지 않는다면 DDD를 제대로 할 가능성이 **없다**라고 까지 이야기한다. 설계가 항상 다른 요소들에 주도될 수 있기 때문이다.

이 책에서 설명한 아키텍처 스타일을 사용할지 말지를 결정할 첫 지표로서, `만약 도메인 코드가 애플리케이션에서 가장 중요한 것이 아니라면 이 아키텍처 스타일은 필요하지 않을 것`이다라고 책은 이야기한다.

#### 흠 도메인 코드가 가장 중요한 상황..?
책에서는 결국 `만약 도메인 코드가 애플리케이션에서 가장 중요한 상황`에서 헥사고날을 사용하라고 한다.

음.....`도메인 코드가 애플리케이션에서 가장 중요한 상황`이란 무엇일까? 어떤 케이스가 있을까. 좀 구체적으로 떠올려보자.

내 생각은 비즈니스 규칙 및 정책이 굉장히 복잡한 경우이다. 

금융 엄계, 보험, 의료 시스템 꼭 그런 쪽이 아니더라도 규제, 정책이 상당히상당히 복잡한 서비스의 경우 도메인 코드가 핵심 비즈니스 로직을 구현하는 것에 매우 중요하다. 도메인 코드가 비즈니스 규칙을 매우 정확하게 반영하고 있는지에 대한 여부가 애플리케이션의 성공 여부를 좌우할 것이다.

그런 상황에서라면 도메인 코드가 무엇보다 제일 중요할 것이다. 비즈니스 규칙과 흐름을 정말 잘 녹여내야한다. 그것도 `가시성 좋게`. 그럴 경우 헥사고날, DDD 같은 개념들이 상당히 중요한 요소가 될 것 같다.

### 경험이 여왕이다.
아키텍처 스타일에 대해 괜찮은 결정을 내리는 유일한 방법은 다른 아키텍처 스타일을 경험해보고 느껴보는 것이다. 책에서는 이 아키텍처에 대한 확신이 없다면 현재 만들고 있는 애플리케이션의 작은 모듈에 먼저 시도해보라고 한다. 나도 동의. 다양한 경험이 있어야 시야가 더욱 명확해질 수 있을 것 같다.

### 그때 그때 다르다
책의 저자도 역시 어떤 아키텍처 스타일을 고를까에 대한 질문에는 "그때 그때 달라요.."라고 한다.
어떤 소프트웨어를 만드느냐에 따라서도 다르고, 도메인 코드의 역할에 따라서도 다르고, 팀의 경험에 따라서도 다르기 때문이다. 매우 동의한다. 실버 불릿은 새상에 없다. 

너무 한 기술, 아키텍처에 매몰되는 일은 없도록 하자.

스터디 끝 !!@ 다들 수고하셨습니다!