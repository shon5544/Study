
코드를 구조화하는 첫 번째 접근법은 계층을 이용하는 것으로서, 다음과 같이 구성할 수 있을 것이다.

![[Pasted image 20231127193307.png]]

웹 계층, 도메인 계층, 영속성 계층 각각에 대해 전용 패키지인 `web`, `domain`, `persistence`를 뒀다. 1장에서 이야기한 것처럼 여러 가지 이유로 간단한 구조의 계층은 가장 적합한 구조가 아닐 수 있다. 

그래서 이번에는 먼저 의존성 역전 원칙을 적용해서 의존성이 `domain` 패키지에 있는 도메인 코드만을 향하도록 해뒀다. 여기서는 `domain` 패키지에 `AccountRepository` 인터페이스를 추가하고, `persistence` 패키지에 `AccountRepositoryImpl` 구현체를 둠으로써 의존성을 역전시켰다.

그러나 적어도 세 가지의 이유로 이 패키지 구조는 최적의 구조가 아니다.

### 첫 째
> 💡 쉽게 이야기 해보자면 결국 관계 없는 기능들이 막 섞이게 되어 굉장히 불편하게 된다는 뜻이다.
> ex) Account, AccountRepository, User, UserRepository, UserService.... 등등

애플리케이션의 기능 조각(functional slice)이나 특성(feature)을 구분 짓는 패키지 경계가 없다. 이 구조에서 사용자를 관리하는 기능을 추가해야 한다면 `web` 패키지에 `UserController`를 추가하고, `domain` 패키지에 `UserService`, `UserRepository`, `User`를 추가하고 `persistence` 패키지에 `UserRepositoryImpl`을 추가하게 될 것이다. 추가적인 구조가 없다면, **아주 빠르게 서로 연관되지 않은 기능들끼리 예상하지 못한 부수효과를 일으킬 수 있는 클래스들의 엉망진창 묶음**으로 변모할 가능성이 크다.

### 둘 째
애플리케이션이 어떤 유스케이스들을 제공하는지 파악할 수 없다. `AccountService`와 `AccountController`가 어떤 유스케이스를 구현했는지 파악할 수 있겠는가? 특정 기능을 찾기 위해서는 어떤 서비스가 이를 구현했는지 추측해야 하고, 해당 서비스 내의 어떤 메서드가 그에 대한 책임을 수행하는지 찾아야 한다.

### 셋 째
패키지 구조를 통해서는 우리가 목표로하는 아키텍처를 파악할 수 없다. 육각형 아키텍처 스타일을 따랐다고 추측할 수는 있고, 그렇기 때문에 웹 어댑터와 영속성 어댑터를 찾기 위해 `web`, `persistence` 패키지의 클래스들을 조사해볼 수 있다. 하지만 어떤 기능이 웹 어댑터에서 호출되는지, 영속성 어댑터가 도메인 계층에 어떤 기능을 제공하는지 한눈에 알아볼 수 없다. `인커밍(incoming)` 포트와 `아웃고잉(outgoing)` 포트가 코드 속에 숨겨져 있다.

## 기능으로 구성하기
`계층으로 구성하기` 방법의 몇 가지 문제를 해결해보자.

![[Pasted image 20231127195026.png]]
> 기능을 기준으로 코드를 구성하면 기반 아키텍처가 명확하게 보이지 않는다.

위의 접근법은 예제 코드를 기능으로 구성한 것이다.

가장 본질적인 변경사항은 계좌와 관련된 모든 코드를 최상위의 `account` 패키지에 넣었다는 점이다. 계층 패키지들도 없앴다.

각 기능을 묶은 새로운 그룹은 `account`와 같은 레벨의 새로운 패키지로 들어가고, 패키지 외부에서 접근되면 안 되는 클래스들에 대해 `package-private` 접근 수준을 이용해 패키지 간의 경계를 강화할 수 있다.

패키지 경계를 `package-private` 접근 수준과 결합하면 각 기능 사이의 불필요한 의존성을 방지할 수 있다.

또한 `AccountService`의 책임을 좁히기 위해 `SendMoneyService`로 클래스명을 바꿨다(이는 계층에 의한 패키지 구조 방식에서도 할 수 있긴 했다). 이제 '송금하기' 유스케이스를 구현한 코드는 클래스명만으로도 찾을 수 있게 됐다.

애플리케이션의 기능을 코드를 통해 볼 수 있게 만드는 것을 가리켜 로버트 마틴이 `소리치는 아키텍처(screaming architecture)`라고 명명한 바 있다. 왜냐하면 코드가 그 의도를 우리에게 소리치고 있기 때문이다.

그러나 기능에 의한 패키징 방식은 사실 계층에 의한 패키징 방식보다 아키텍처의 `가시성을 훨씬 더 떨어뜨린다.` 어댑터를 나타내는 패키지 명이 없고, 인커밍 포트, 아웃고잉 포트를 확인할 수 없다. 심지어 도메인 코드와 영속성 코드 간의 의존성을 역전시켜서 `SendMoneyService`가 `AccountRepository` 인터페이스만 알고 있고 구현체는 알 수 없도록 했음에도 불구하고, `package-private` 접근 수준을 이용해 도메인 코드가 실수로 영속성 코드에 의존하는 것을 막을 수 없다. 

그럼 한눈에 파악하기 쉬운 아키텍처는 어떻게 만들 수 있을까? 

아래와 같은 아키텍처 다이어그램에서 어떤 박스를 가리켰을 때 코드의 어떤 부분이 해당 박스를 책임지는지를 바로 알 수 있다면 좋을 것이다.

![[Pasted image 20231127210231.png]]

이를 위해 한 걸음 더 나아가 표현력 있는 패키지 구조를 만들어 보자.

## 아키텍처적으로 표현력 있는 패키지 구조
육각형 아키텍처에서 구조적으로 핵심적인 요소는 엔티티, 유스케이스, 인커밍/아웃고잉 포트, 인커밍/아웃고잉(혹은 주도하거나 주도되는) 어댑터다. 이 요소들을 예제 애플리케이션의 아키텍처를 표현하는 패키지 구조로 구성해보자.

![[Pasted image 20231127210435.png]]

구조의 각 요소들은 패키지 하나씩에 직접 매핑된다. 최상위에는 `Account`와 관련된 유스케이스를 구현한 모듈임을 나타내는 `account` 패키지가 있다.

그 다음 레벨에는 도메인 모델이 속한 `domain` 패키지가 있다. `application` 패키지는 도메인 모델을 둘러싼 서비스 계층을 포함한다. `SendMoneyService`는 인커밍 포트 인터페이스인 `SendMoneyUseCase`를 구현하고, 아웃고잉 포트 인터페이스이자 영속성 어댑터에 의해 구현된 `LoadAccountPort`와 `UpdateAccountStatePort`를 사용한다.

`adapter` 패키지는 애플리케이션 계층의 인커밍 포트를 호출하는 인커밍 어댑터와 애플리케이션 계층의 아웃고잉 포트에 대한 구현을 제공하는 아웃고잉 어댑터를 포함한다. `BuckPal` 예제의 경우 각각의 하위 패키지를 가진 `web` 어댑터와 `persistence` 어댑터로 이뤄진 간단한 웹 애플리케이션이 된다.