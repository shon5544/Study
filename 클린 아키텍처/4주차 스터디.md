> 문어체는 책 내용 정리고 경어체는 제 생각을 말하는 부분이라고 생각해주시면 될 것 같아요.


# 7장 아키텍처 요소 테스트하기
## 테스트 피라미드
- 흔히 이야기되는 그 피라미드
- 단위 테스트가 제일 넓은 최하층에 있고, 그 위에 통합 테스트, 시스템 테스트가 있는 구조
- 단위 테스트: 
	- 피라미드의 토대로, 일반적으로 하나의 클래스를 인스턴스화해서 기능들을 테스트. 
	- 테스트 대상이 다른 의존성을 가지고 있다면 그에 해당하는 부분들은 mocking한다.
- 통합 테스트:
	- 연결된 여러 유닛을 인스턴스화 시켜서 시작점이 되는 클래스의 인스턴스로 데이터를 보내 테스트 한다.
	- 목적은 여러 유닛들의 네트워크가 기대한대로 잘 동작하는지 검증하기 위해서.
	- 어떤 시점에서는 얘도 mocking 인스턴스를 대상으로 굴러가야할 수도 있다.
- 시스템 테스트:
	- 애플리케이션을 구동하는 모든 객체 네트워크를 가동시켜 테스트.
	- 특정 유스케이스에 대해 전 계층에서 정상 동작하는지 검증하기 위해서.

## 단위 테스트로 도메인 엔티티 테스트하기
- 내용은 크게 뭐가 없었다. 도메인 엔티티에 녹아 있는 비즈니스 규칙을 검증했다.
- 도메인 엔티티 자체는 다른 클래스에 거의 의존하지 않기 때문에 정말 쉽고 빠르게(만들때나 실행할 때나)테스트를 돌릴 수 있었다.

## 단위 테스트로 유스케이스 테스트하기
### 비즈니스 규칙
- SendMoney 유스케이스는 출금 계좌가 다른 트랜잭션에 의해 변경되지 않도록 락을 건다.
- 출금 계좌에서 돈이 출금되고 나면 똑같이 입금 계좌에 락을 걸고 돈을 입금시킨다. 
- 그러고 두 계좌 모두 락을 푼다.
- 이러한 비즈니스 규칙이 제대로 검증되었는지를 보는 테스트 코드였다.

### 유스케이스 테스트 코드
- Mockito 기반으로 BDD, 그 속에서도 given/when/then 컨셉을 이용했다. (when문은 딱히 사용하지 않긴 했음)
- 테스트 중인 유스케이스 서비스는 **상태**가 딱히 없기 때문에 'then'을 통한 특정 상태를 검증할 수 없다.
- 따라서 테스트는 서비스가 (모킹된) 의존 대상의 특정 메서드와 상호작용했는지 여부를 검증한다.
- 이는 테스트가 코드의 행동 변경뿐만 아니라 코드의 구조 변경에도 취약해진다는 의미.
- 그렇기에 프로덕션 코드가 리팩토링 되면 테스트 코드도 같이 바뀌게될 확률이 높아진다.
- 그래서 테스트에서 어떤 상호작용을 검증하고 싶은지를 신중하게 정해야한다.
- 책에서의 예제처럼 모든 동작을 검증하려고 하면 클래스가 조금이라도 바뀔 때마다 테스트를 수정해야한다.


### 이러한 상호 작용 테스트에 대하여..
- 객체의 어떤 메서드의 호출 자체에 대한 검증들을 `상호 작용 테스트`라고 합니다.
- 저는 이러한 행동 기반 테스트가 굉장히 자연스럽지 못한 방식이라고 배웠습니다.
	- 물론 Silver Bullet은 없으니 개인이 생각하기 나름입니다.
- 왜 안 좋냐? 이러한 테스트가 사실 굉장히 어거지여서 그렇습니다.
- 함수가 호출되었는지 보기 위해 테스트 대상(sut)의 내부 구현을 까고 들어가는(리플렉션 등을 통해) 식인건데, 그 과정에서 객체의 캡슐화라던지 무시하면서 참조하게 됩니다.
- 또 책에서 언급했듯이 구조 변경에도 취약해집니다. 비즈니스 로직 수정에 취약하니까요.
- 이러한 테스트들이 자연스럽지 않기 때문에, **메서드의 반환 값을 이용한** `상태 기반 테스트`를 주로 해야한다고 합니다.
- 저도 그렇고 책에서도 이러한 상호 작용 테스트는 권장하지 않는 것으로 보이니, 가능한 메서드의 반환 값을 이용한 상태 기반 테스트를 하는 것이 좋아보이는데, **여러분들의 생각은 어떠신가요?**
	- 막말로 어떤 상호작용을 검증하고 싶은지만 잘 정하면(사이드 이펙트를 최소화하면) 또 못할 건 없다고 생각하긴 합니다.

## 통합 테스트로 웹 어댑터 테스트하기
- MockMvc를 이용한 테스트 코드였음.
- 이를 이용해 api endpoint에 mock http 요청을 보내는 식으로 테스트를 했음.
- 그다지 특별한 내용은 없었던 것 같습니다.

## 통합 테스트로 영속성 어댑터 테스트하기
- `@DataJpaTest` 어노테이션을 통한 테스트.
- `@DataJpaTest`는 `@SpringBootTest`와 거의 유사한데 JPA 영속성 관련 의존성만을 준비하라는 어노테이션입니다.
	- 좀 TMI긴 한데 `@DataMongoTest`라는 것도 있습니다. JPA 대신 MongoDB를 쓸 때 쓰는 거에요. 기능적으로는 거의 동일합니다.
	- 그 외의 DB에 대해서는 도커를 통한 `TestContainer`를 이용해 영속성 테스트를 할 수 있는 거로 알고 있어요.
- 책의 테스트에서는 DB 관련 모킹을 하지 않았음. 테스트가 실제 DB에 접근하는 코드.
- 영속성 어댑터 테스트는 SQL 방언 문제 등의 문제로 인해 인메모리와 프로덕션이 다르게 돌 수 있으므로 실제 DB를 대상으로 해야한다고 한다.
- TestContainers 같은 걸 통해 도커에서 할 수 있으므로 이런 측면에선 아주 유용하다고 한다.

## 시스템 테스트로 주요 경로 테스트하기
- `@SpringBootTest` 를 이용한 테스트였습니다.
- 크게 특별할 건 없었습니다.
	- 그나마, 
		- 헬퍼 메서드들이 여러가지 상태를 검증하기 위한 DSL을 형성한다는 점
		- JGiven 같은거 쓰면 테스트용 어휘를 만드는데 도움이 된다는 점
		- 시스템 테스트는 여러 유스케이스들을 결합하여 시나리오를 만들 때 빛이난다는 점
	- 이정도인 것 같습니다.

## 얼만큼의 테스트면 충분할까?
- 책의 저자는 얼마나 마음 편히 소프트웨어를 배포할 수 있느냐를 기준으로 삼는다고 한다.
	- 나름 합리적일수는 있을 것 같은데... 
	- 이러한 기준은 사람들마다 다르기 때문에 팀내에서 규정할 수 있는 객관적 기준이 있는편이 훨씬 나을 것 같긴 해요.
- 육각형 아키텍처에서의 테스트 전략:
	- 도메인 엔티티 구현시엔 단위 테스트로 커버하자
	- 유스케이스를 구현할 때는 단위 테스트로 커버하자
	- 어댑터를 구현할 때는 통합 테스트로 커버하자
	- 사용자가 취할 수 있는 중요 어플리케이션 경로는 시스템 테스트로 커버하자

- 책이랑은 살짝 맥락이 다른 것 같기도 한데 이 영상에 대해서도 한번 참조해보고 의견 나눠보면 좋을 것 같아요. 최근에 접한 지금까지와 좀 다른 생각을 전해주는 영상이었어요.
	- https://www.youtube.com/watch?v=gs1qM1TF5zA
	- 요약본:
		- 소프트웨어 개발, 테스팅 또한 경제적인 활동이다. 
		- 자원(시간, 인력)을 적게 투입하여 최대한의 효용을 뽑아내어야 한다 
		- 코드에 따라 유닛 테스트는 필요할 때도 있고 필요하지 않을 때도 있다. 
		- 유닛 테스트가 필요한 경우는 다음과 같다 
			- 1) 알고리즘이 매우 복잡하지만 수학적으로 잘 정의된 경우, 구현 상의 명백한 버그를 없애기 위해 필요하다 
			- 2) 제품이 실제로 사용되고 발전하면서 자꾸 변하거나 가정이 틀리는 부분의 버그를 없애기 위해 필요하다 
		- 1에서는 TDD가 어느 정도 유용할 수 있으나 2에서는 쓸모가 없다. 
		- 코드의 어떤 부분이 변경될지 예측하는 것은 어렵기 때문이다. 
		- 1은 애초에 안 변하고, TDD 방식으로 모든 코드에 대해 테스트를 짤 경우, 특히 2에서 코드를 변경해야하는데 테스트가 발목을 잡는다. 
		- 그러므로 (포프는) 제품 코드 전에 테스트 코드를 짜자는 TDD 방식을 쓰지 않는다. 
		- **일단 코드를 그냥 짜고, 실제로 버그가 일어나고 가정이 틀리는 시점에서 그에 대한 테스트 코드를 작성한다.**

# 8장 경계 간 매핑하기
- 진짜 늘 맨날 고민되는 부분이였어요.
- 계층간 dto 매핑에 대한 이야기였습니다.
- 각각의 트레이드 오프를 생각해볼 수 있는 시간이었습니다.

## 매핑하지 않기 전략
- 그냥 전 계층에 걸쳐 도메인 모델을 쓰는 전략
- 웹 계층과 영속성 계층은 모델에 대한 특별한 요구 사항이 있을 수 있다.
- ex) 웹 계층에서 REST로 모델 노출 시 모델을 직렬화하기 위한 어노테이션 혹은 함수를 만들어야할 수 있음.
- ex) 영속성 계층에서 ORM 프레임워크를 사용한다면 DB 매핑을 위한 특정 어노테이션이 필요할 수도 있음.
- 도메인과 애플리케이션 계층은 웹이나 영속성에 관련한 특수 요구사항에 관심이 없다.
- 그럼에도 이러면 모든 요구사항을 다뤄야한다는 것.
- 이를 통해 SRP가 깨진다.

### 매핑하기 전략을 쓰면 안 될까?
- 이 매핑하지 않기 전략이 딱 들어맞을 때가 있음
- 모든 계층이 정확히 같은 구조의, 정확히 같은 정보를 필요로 한다면 매핑하지 않기 전략은 완벽한 선택지다.
- 개인적인 직관으론 `비즈니스 로직이 단순할 수록 매핑하기 전략이 좋다` 정도로 이해했습니다.

## 양방향 매핑하기 전략
![[Pasted image 20240605224359.png]]
- 표현 계층과 영속성 계층에 모델을 둔다.
- **장점:**
	- 각 계층이 전용 모델을 가지고 있는 덕분에 각 계층이 전용 모델을 사용하더라도 다른 계층에는 영향이 없다.
		- 그렇기에 웹 모델은 데이터를 최적으로 표현할 수 있고
		- 도메인 모델은 유스케이스를 잘 구현할 수 있는 구조를 가지고있다.
		- 영속성 모델은 ORM에서 필요로하는 구조로 할 수 있다.
	- 이 전략을 통해 웹, 영속성에 영향받지 않는 깨끗한 도메인을 만들어낼 수 있다.
	- 또다른 장점으로는 '매핑하지 않기' 전략 다음으로 간단한 전략이기 때문이다.
		- 매핑 책임이 명확하다.
- **단점:**
	- 너무 많은 보일러 플레이트 코드가 생긴다. 
		- 코드의 양을 줄이기 위해 매핑 프레임워크를 사용하더라도 두 모델 간 매핑을 구현하는 것에 꽤 시간이 든다.
	- 도메인 모델이 계층 경계를 넘어서 통신하는데 사용되고 있다는 것.
		- 도메인 모델은 필요에 의해 변경되어지는 것이 이상적이다. 
		- 그러나 이렇게 경계를 넘나들면 바깥쪽 계층의 요구에 따른 변경에 취약해진다.
- **Shon이 생각하는 중요한 메시지:**
	- 어떤 매핑 전략도 철칙처럼 여겨서는 안 된다.
	- 각 유스케이스마다 적절한 전략을 사용하는 것이 적절하다.

## 완전 매핑 전략
![[Pasted image 20240606003659.png]]
- 각 연산마다 별도의 입출력 모델을 사용한다.
- 계층 경계를 넘어 통신할 때 도메인 모델을 사용하는 대신, 입력 모델로 동작하는 `SendMoneyCommand`처럼 각 작업에 특화된 모델을 사용한다.
- 이런 모델을 가르켜 `커맨드(Command)`, `요청(Request)` 혹은 이와 비슷한 단어로 표현된다.
- 당연히 복잡해지고 코드가 많아진다.
- 그러나 이는 다양한 유스케이스를 함께 다뤄야하는 상황에서 유지보수하기 쉬워진다.
- 책에서는 이 매핑 전략은 전역 패턴으로 추천하지는 않는다.
- 이 전략은 인커밍 어댑터와 애플리케이션 계층 사이에서 상태 변경 유스케이스의 경계를 명확하게할 때 가장 빛을 발한다.
- 애플리케이션 계층과 영속성 계층 사이에서는 매핑 오버헤드 때문에 오히려 사용하지 않는게 좋다.
- 재밌는 점은 책에서는 이러한 다양한 매핑전략을 섞어쓰는걸 강력 권장하는 것이다.
	- **섞어 써야만 한다.** 라는 표현까지 나올정도..
	- 어떠한 매핑 전략도 모든 계층에 걸친 전역 규칙일 필요가 없다고 한다.
	- 저는 일관성의 문제로 인한 고민을 했었는데(전역적으로 해야하나) 일관성에 집착할 필요가 없다고 하니 꽤나 흥미로운 부분이었습니다.

## 단방향 매핑 전략
![[Pasted image 20240606005047.png]]
- 이 전략에서는 모든 계층의 모델들이 같은 인터페이스를 공유한다.
- 이 인터페이스는 관련있는 특성(attribute; 저는 필드 값이라고 일단은 이해했습니다.)에 대한 getter 메서드를 제공해서 도메인 모델의 상태를 캡슐화한다.
- 도메인 모델을 애플리케이션 계층의 서비스에서 핸들링하고 있을 때 이 데이터를 바깥 계층으로 전달하고 싶을 수 있다.
- 이럴 때 그냥 매핑 없이 그냥 할 수 있다.
- 왜냐하면 도메인 객체가 인커밍/아웃고잉 포트가 기대하는 대로 상태 인터페이스를 구현하고 있기 떄문이다.
- 바깥 계층에서는 상태 인터페이스를 이용할지, 전용 모델로 매핑할 지 결정할 수 있다. 
- 행동을 변경하는 것이 상태 인터페이스에 의해 노출되어 있지 않기 때문에 실수로 도메인 객체의 상태를 변경하는 일은 발생하지 않는다.
- 이 전략에서의 매핑 책임은 명확하다. 
- **한 계층이 다른 계층으로부터 객체를 받으면 해당 계층에서 이용할 수 있도록 다른 무언가로 매핑하는 것이다.**
- 그래서 각 계층은 한 방향으로만 매핑한다.
- 그래서 `단방향 매핑`이다.
- **이 전략이 가장 효과적인 상황**은 `계층 간 모델이 비슷할 때`이다.
- 읽기 전용 연산의 경우 상태 인터페이스가 필요한 모든 정보를 제공하기 때문에 웹 계층에서 전용 모델로 매핑할 필요가 전혀 없다.


## 언제 어떤 매핑을 사용할 것인가?
- 결론적으로 `그때 그때 다르다`이다.
- **중요한 포인트:**
	- 매핑 전략이 각 장단점을 가지고 있기 때문에 한 전략을 프로젝트 전역적으로 쓸 필요가 없다는 점. 책에선 그 충동을 이겨내라고 한다.
		- 상황에 맞는 최선의 선택이 아님에도 깔끔해 보인다는 이유로 선택해버리는 건 참 무책임한 처사라고 한다. ㅠ.ㅠ
	- 고정된 매핑전략을 유지하는 것보다는 빠르게 코드를 짤 수 있는 간단한 전략으로 시작해 계층 간 결합을 떼어내는 것에 도움이 되는 복잡한 전략으로 갈아타는 것도 좋다!
	- 팀 내에서 합의 가능한 가이드라인이 있어야한다.
		- 이 가이드라인의 핵심은 어떤 상황에서 어떤 매핑 전략을 가장 먼저 택해야 하는가에 대한 **답할 수 있어야한다는 것**이다.
		- 책에 가이드라인에 대한 구체적인 예시가 있었다. 필요하다면 다시 참조해보자.
		- 이 가이드라인이라는 것은 팀 차원에서 **지속적으로 논의되고 수정되어야한다는 점이 좀 중요한 것 같다.**

