
## 9장: 애플리케이션 조립하기
### 왜 조립까지 신경써야 하나?
이런 생각이 들 수 있다. 그냥 유스케이스든 어댑터든 그냥 필요할 때 인스턴스화 하면 안 되는걸까?
책에서는 안 된다고 한다. 왜냐, 코드 의존성이 올바른 방향을 가리켜야하기 때문이다.

모든 의존성은 안쪽으로, 그러니까 애플리케이션의 도메인 코드는 아무런 의존성을 가지지 않아야 바깥 계층의 변경으로부터 안전해지기 때문이다.

근데 유스케이스가 영속성 어댑터를 호출하고 스스로 인스턴스화 한다면 코드 의존성이 잘못된 것이다.
그니까 이게 뭔 말이냐, 직접 이걸 조립하는 과정에서 어쩔 수 없이 포트에 들어갈 수 있는 어댑터를 직접 구현해서 넣게되기 때문이다.

유스케이스는 포트 인터페이스만 알아야하고, 런타임에 이 인터페이스의 구현을 제공받아야한다. 컴파일 타임이 아니라.

이렇게 했을 때의 장점은 많이들 알고 있을거라고 믿는다. 당연히 진정으로 느슨한 의존관계를 만들 수 있으며 이는 유지보수도 쉽지만 Testability의 상승을 의미하기도 하기 때문이다.

그렇다면 우리의 객체 인스턴스를 생성할 책임은 누구에게 있을까? 

![[Pasted image 20240703170135.png]]
바로 모든 클래스에 전역적으로 의존성을 가지는 설정 컴포넌트가 그 책임을 진다.

설정 컴포넌트는 우리가 개발한 코드들을 조합해 애플리케이션을 조립하는 것을 책임진다.

이 컴포넌트의 역할이란 다음과 같다.
- 웹 어댑터 인스턴스 생성
- HTTP 요청이 웹 어댑터로 전달되도록 보장
- 유스케이스 인스턴스 생성
- 웹 어댑터에 유스케이스 인스턴스 제공
- 영속성 어댑터 인스턴스 생성
- 유스케이스에 영속성 어댑터 인스턴스 제공
- 영속성 어댑터가 실제로 데이터베이스에 접근할 수 있도록 보장

정리하고 보니 이거 다 스프링이 해주는 거다. 스프링 같은 IoC을 해주는 것이 없으면 사실상 애플리케이션 조립 과정에서 강결합이 이뤄질 수밖에 없는 것이다. TMI지만 그렇기에 내가 알기론 DI는 IoC가 이뤄짐을 전제로 사용한다고 알고 있다.

더불어서 설정 컴포넌트는 설정 파일 및 커맨드라인 파라미터 등 설정 파라미터와 db 접근 등 외부 서버와의 연결에 대한 행동 양식도 제어해야한다.

이거 단일 책임 원칙 위반하는 거 아니에요? 위반이 맞다. 근데 애플리케이션 코어 외적인 부분을 깔끔하게 유지하려면 이건 꼭 필요하다. 그래서 어쩔 수 없다.

### 평범한 코드로 조립하기..?
![[Pasted image 20240703171023.png]]
이거는 초 간단 그냥 애플리케이션의 구성 연결을 직접 구현한거다. 

당연히 HTTP 연결을 웹 어댑터로 연결하는 구현 코드도 없고(startProcessingWebRequests로 사용은 하지만 내부 구현은 가려져있다) 그 외 위에서 말한 수많은 설정 구현을 하지 않은 거다. 예제를 위해 간단하게 작성된 모습.

아찔하지 않나? 이런 걸 직접 구현하는 건 매우 힘든 일이다. 다행히도 이러한 지저분한 작업을 대신 처리해줄 수 있는 여러 프레임워크가 많다. 그 중에서도 한국은 스프링이 매우 인기있다.

### 스프링 클래스패스 스캐닝으로 조립하기
그냥 우리가 아는 방식입니다. 특별할게 없어요.

조금 신선했던건 아키텍처의 구성요소를 명확히 하기 위해 `@Component` 어노테이션을 포함하는 우리만의 새로운 어노테이션 `@PersistenceAdapter`를 사용하는 것이었는데, 구현에 대해선 딱히 특별할게 없었습니다. 그냥 @Component낀 어노테이션 만들면 됨.

그 이상으로 특별했던 내용은 없었던 것 같습니다.

### 스프링 자바 컨피그로 조립하기
![[Pasted image 20240703172403.png]]
`@EnableJpaRepositories`를 통해 영속 어댑터를 직접 빈으로 등록할 수 있다.

이 방식으로 하면 구현 객체 변경도 깔끔하고 테스트 전용으로 설정 클래스를 만들어서 모킹하기는 것도 깔끔해질 것이다.

물론 문제점이 있긴 한데, 생성하는 빈 클래스들이 설정 클래스와 같은 패키지에 존재하지 않는다면 이 빈들을 public으로 만들어야한다. 가시성을 제한하기 위해 패키지를 모듈 경계로 사용하고 각 패키지 안에 전용 설정 클래스를 만들 수는 있다. 그러나 이렇게 하면 하위 패키지를 사용할 수 없는 단점이 있긴 하다.

그래도 이러한 전용 설정을 여러개 둠으로써 설정 컴포넌트의 책임을 분산할 수 있기 때문에 응집도가 매우 높은 모듈을 만들 수 있다는 것이 장점이다.

## 10장 아키텍처 경계 강제하기
### 경계와 의존성
경계를 강제한다라는 것이 무슨 의미인지 알아보도록 하자.

![[Pasted image 20240703181436.png]]
사진에도 나와있듯 경계를 강제한다는 것은 계층에 맞도록 컴포넌트를 구성하고, 의존성이 올바른 방향을 향하도록 강제하는 것을 의미한다. 계속해서 언급되어 왔지만 이러한 강제는 소프트웨어 유지보수성을 높일 수 있다.

### 접근 제한자
경계를 강제하기 위한 가장 기본적인 도구는 바로 접근 제한자이다.
많이들 간과하는 것이 바로 package-private(혹은 default) 제한자이다.
이 접근 제한자가 중요한 이유는 패키지 안에서만 동작하도록 만들어 물리적인 '응집'을 구현하도록 하기 때문이다. 이러한 응집이 잘못된 의존방향을 만들지 않도록 만들어준다.

![[Pasted image 20240703181842.png]]
접근 제한자를 염두에 두고 언급된 패키지 구조를 살펴보도록 하자.
package private이 가능한 녀석들은 위 사진에서 'o'표시가 된 것들이다.

일단 어떤 맥락으로 package private이 가능한지 보이지 않나? 각 계층을 담당하는(domain 제외) 구체 클래스는 다 package-private이 가능하다. 설정 컴포넌트가 런타임에 di를 해주는 것은 다 리플렉션 api등을 쓰기 때문에 가능하고, 우리가 사용하는 단에서 구체 클래스는 가져다 쓰지 않기 때문에(domain 제외) 가능하다.

그리고 이렇게 해줬을 때 각 계층간 구체 컴포넌트를 참조할 수 없으니 물리적 응집이 생길 수 밖에 없다.

그 외의 나머지 public으로 둬야하는 것은 '+'로 표기 되어있다. 다른 계층에서 참조가 가능해야하기 때문이다.

package-private 제한자는 몇 개 정도의 클래스로만 이뤄진 작음 모듈에서 가장 효과적이다. 그러나 패키지 내의 클래스가 특정 개수를 넘어가기 시작하면 하나의 패키지에 너무 많은 클래스를 포함하는게 되게 혼란스러워진다. 이 때는 코드를 쉽게 찾을 수 있도록 하위 패키지를 만드는 방법을 책에서는 추천한다.

그러나 하위 패키지는 다른 패키지로 인식이 되기 때문에 하위에 속하는 멤버들은 전부 public이어야하는걸 염두에 둬야한다. 이는 아키텍처에서 의존성 규칙이 깨질 수 있는 환경이 만들어질 수 있기 때문에 조심해야한다.

### 컴파일 후 체크
클래스에 public 제한자가 쓰이면 의존성 방향이 잘못되더라도 컴파일러는 다른 클래스들이 이걸 쓸 수 있도록 허용한다. 컴파일러가 이 경우엔 도움이 안 되니 이 의존성 규칙을 체크할 다른 수단을 써야한다.

컴파일 후 체크를 도입함으로써 이를 해결할 수 있긴 하다. 문법적인 문제를 컴파일에서 하고, 의존성에 관련된 문제를 런타임에 체크하는 것이다.

ArchUnit이라던지 이런 도구들을 써서 체크를 하도록 할 수 있다.

![[Pasted image 20240703184312.png]]
![[Pasted image 20240703184319.png]]
![[Pasted image 20240703184327.png]]
이러한 DSL을 작성하여 패키지 간의 의존 방향이 제대로 되었는지 체크할 수 있다.

이게 잘못된 의존성을 바로 잡게 많은 도움을 주지만, 실패에 안전하지는 않다. 패키지 이름을 잘못쓰면 어떤 클래스도 못찾으니까 의존성 규칙 위반 사례를 발견하지 못한다.

방지하기 위해 클래스를 하나도 찾지 못했을 때 실패하는 테스트를 추가할 수 있다. 그럼에도 여전히 리팩토링에 취약하긴 하다. 컴파일 후 체크는 언제나 코드와 함께 유지보수 되어야한다는 점을 기억하자.

### 빌드 아티팩트
Maven, Gradle 같은 빌드 도구들의 주요 기능 중 하나는 의존성 해결이다. 어떤 코드 베이스를 빌드 아티팩트로 변환하기 위해 빌드 도구가 코드 베이스가 의존하고 있는 모든 아티팩트가 사용가능한지 확인할 수 있다.

만약 사용 불가능한 것이 있다면 아티팩트 리포지토리로부터 가져오려고 시도한다. 이마저도 실패하면 코드를 컴파일 하기 전에 빌드가 실패한다.

이를 활용해 모듈과 아키텍처의 계층 간 의존성을 강제할 수 있다. 각 모듈 혹은 계층에 대해 전용 코드베이스와 빌드 아티팩트로 분리된 빌드 모듈(JAR 파일)을 만들 수 있다.

각 모듈의 빌드 스크립트에서는 아키텍처에서 허용하는 의존성만 지정하기에 잘못된 의존성을 만들 수 없다.