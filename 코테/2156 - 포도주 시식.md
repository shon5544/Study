
## 문제
https://www.acmicpc.net/problem/2156

## 어프로치
개미전사와 비슷하게 간다.

문제 상황을 천천히 분석해보자.

6잔의 포도주 ( 6, 10, 13, 9, 8, 1 ) 가 있다고 생각해보자.
내가 9와 8을 이미 마셨으면 1을 마실 수 없으며
13과 9을 마셨으면 1을 마실 수 있다.

이렇게 따져서 가장 많은 양을 마실 수 있는 양을 골라주면 된다는 것이다.

현재 포도주를 마실지 말지 결정할 땐 다음과 같은 경우로 나눌 수 있다.
1. 현재 포도주와 전 포도주를 마시고 전전 포도주는 마시지 않는다. `(wine[i] + wine[i - 1] + d[i - 3])`
2. 현재 포도주와 전전 포도주를 마시고 이전 포도주는 마시지 않는다. `(wine[i] + d[i - 2])`
3. 현재 포도주를 마시지 않는다.`(d[i - 1])`

전전전 포도주, 전전전전 포도주... 이런 것들은 고려할 필요가 없다. 왜냐하면 d를 통해 값들을 누적해서 가져오기 때문이다!

위의 케이스에선 보기 좋게 wine이라고 이야기 했지만 실제 풀이에선 arr라는 변수를 썼다.
## 코드
```python
import sys

input = sys.stdin.readline

n = int(input().rstrip())

arr = [0] * 10000
for i in range(n):
    arr[i] = int(input())

d = [0] * 10000
d[0] = arr[0]
d[1] = arr[0] + arr[1]
d[2] = max(arr[2] + arr[0], arr[2] + arr[1], d[1])
for i in range(3, n):
    d[i] = max(arr[i] + d[i - 2], arr[i] + arr[i - 1] + d[i - 3], d[i - 1])

print(max(d))
```