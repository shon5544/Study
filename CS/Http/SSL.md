
## SSL, TLS란?
> 용어의 정리.
- SSL: Secure Sockets Layer
- TLS: Transport Layer Security

두 용어의 더 자세한 정의와 함께 어떤 차이가 있는지 확인해보자.

## SSL
**SSL**은 인터넷의 초기 시기에서 웹 보안을 강화하기 위한 필요성에서 비롯되었다. 초창기 HTTP는 데이터를 평문으로 전송했는데, 중간에 가로채는 등의 공격에 취약했다. 특히 전자 상거래와 같이 민감한 정보가 오가는 경우 이러한 도청이 매우 위험할 수 밖에 없다.

그래서 네트워크 보안의 중요성이 대두되며 데이터를 전송하면서 암호화를 도입하게 되었는데 이때 시행되었던 시도가 SSL 인증서를 이용한 데이터 암호화 및 인증이다. 이를 통해 더욱 안전하게 데이터를 보내고 받을 수 있게 되었다. 

이러한 SSL이 적용된 사이트의 가장 큰 특징이 그 유명한 https인데, 돈 거래 등 민감한 케이스에 사용했었지만 지금은 사실상 표준이 되어 전역적으로 다 사용한다. 안 쓰는 곳이 정말 없음.

> ++ SSL
> 사실 SSL은 보안 소켓 계층을 의미할 뿐이지만 위의 일련의 인증 방식을 일컫는 프로토콜 이름/방법론으로 사용되는 경향이 있는 듯하다. 소수가 그러는 것이 아닌 대다수가 그렇기 때문에 그냥 하나의 방법론으로 일반화하여 설명을 해보겠다.

## TLS
이렇게 보면 정말 SSL을 많이 쓸 것 같지만, 이젠 SSL은 완전히 도태됐다. 
왜냐하면 기존 SSL에는 여러 취약점이 있었기 때문인데,

1. **암호화 강도 부족:**
    - SSL 2.0은 매우 약한 암호화 알고리즘을 사용했음.
2. **핸드셰이크 취약점:**
    - SSL 2.0은 핸드셰이크 프로토콜에서 중간자 공격(man-in-the-middle attack)에 취약했다. 
	    - 중간자 공격: 
		    - `유저 -> 서버`가 아닌, `유저 -> 공격자 -> 서버`의 방식으로 공격자가 통신을 중계하는 것.
		    - 당연히 유저가 서버한테 뭘 보내는지 알 수 있고 데이터 변조도 가능함.
3. **세션 재개 기능의 문제:**
    - 세션 재개(session resumption) 기능은 세션 키를 암호화하지 않고 전송하여, 공격자가 이전 세션의 데이터를 복원할 수 있는 가능성이 있었음.

등등... 더 많은 이유가 있지만 요정도로 해보자. 아무튼 SSL은 하자가 많던 방식이었다!
TLS는 기존 SSL의 방식에서 취약점들을 보완 개선하여 만들어진 것으로, **SSL의 업그레이드 버전이다.**

CloudFlare 등등 곳곳에서 **TLS로 대체되었다라는 표현을 한다.** 

때문에 엄격히 따지면 요즘에는 TLS라고 부르는게 맞는데, SSL이라는 용어의 보편성 때문에 혼용해서 쓰는 듯하다.

## SSL / TLS 프로토콜
이 프로토콜이 어떻게 이뤄지는지 대략적으로만 그려보자.
먼저 대칭키와 비대칭키에 대한 지식이 있어야한다.

### 대칭 키
하나의 키로 데이터를 암호화하고, 또 복호화한다. 당연히, 이 키가 털리면 끝장이다. 심각한 문제가 발생하는 거다.

### 비대칭 키
![[Pasted image 20240618181057.png]]
공개 키와 개인 키로 암호화 및 복호화를 수행한다.
하나의 키로 암호화 했으면 다른 키로만 복호화 가능하다.

어떻게 상호작용하냐:
- 공개 키로 암호화 한다면 -> 개인 키로만 복호화 가능
- 개인 키로 암호화 한다면 -> 공개 키로만 복호화 가능

대칭 키보다는 확실히 안전하다. 대신에 구현도 복잡하고 속도도 느리다.

### SSL / TLS에서는.
대칭 키와 비대칭 키를 동시에 쓴다.

**대략적인 흐름**
![[Pasted image 20240618181156.png]]
- A가 B로 접속 요청을 보냈을 때.
- B가 A로 자신의 공개 키를 준다.

![[Pasted image 20240618181247.png]]
- A는 자신의 대칭키를 B의 공개 키로 암호화한다.
- 그리고 이걸 B한테 보낸다.

![[Pasted image 20240618181316.png]]
- B는 자신의 개인키로 A의 대칭 키를 얻을 수 있다.

![[Pasted image 20240618181335.png]]
- 이러면 A, B 모두 대칭 키를 공유할 수 있다.
- 이제부터 모든 통신에 A의 대칭키로 암호화해서 B한테 데이터를 보낸다.
- B에서는 A의 대칭키를 가지고 있기 때문에 데이터를 복호화할 수 있다.
- A랑 B만 알 수 있는 소통을 할 수 있다. 아주 그냥 세상이 핑크퐁이지?


### SSL / TLS Handshake
>💡**CA?**
>인증서의 역할은 클라이언트가 접속한 서버가 의도한 서버가 맞는지 보장하는 것이다. 이 역할을 하는 민간 기업들이 있는데 이런 기업들을 CA(Certificate authority) 혹은 Root Certificate라고 부른다. CA는 신뢰성이 엄격하게 공인된 기업들만 참여할 수 있다.
>
>개발자 입장에서 HTTPS를 적용하려면 신뢰할 수 있는 CA 기업의 인증서를 구입해야 한다. 이 인증서를 구입하게 되면 CA 기업의 개인 키를 이용하여 암호화 한 인증서를 준다.

>💡 **SSL 인증서**
>SSL 인증서에는 서비스의 정보 (인증서를 발급한 CA, 서비스의 도메인 등)와 서버 측 공개 키가 들어 있다.
>
>그러면 서버에서는 본인의 개인 키를 생성하였고, 클라이언트가 사용할 공개 키는 인증서 안에 담겨 있는데, 클라이언트는 CA의 개인 키로 암호화 된 인증서를 어떻게 복호화 할까?
>
>바로, 우리가 사용하는 일반적인 브라우저에 신뢰할 수 있는 CA 기관의 리스트와 해당 기관의 공개키를 이미 가지고 있다. 그래서 클라이언트는 내장된 CA의 공개 키를 활용하여 인증서를 복호화함으로써 인증서를 검증한 뒤, 서버의 공개 키를 가져올 수 있다. 

이 과정을 CA 인증서를 끼고 돌리는게 ssl / tls 핸드쉐이크다.
자세하게 알아보자.

![[Pasted image 20240618173525.png]]
- 위의 파란색 프로세스는 우리가 흔히 봤던 것들. TCP 3-way handshake다.
- ClientHello -> SeverHello -> Certificate -> ServerHelloDone -> ClientKeyExchange -> ChangeCipherSpec -> Finished -> ChangeCipherSpec -> Finished로 생각하면 된다.
---
1. **client hello:** 서버에 연결을 시도하면서 전송하는 패킷이다.
	- 자신이 사용가능한 **cipher suit 목록**, session id, ssl 프로토콜 버전, **random byte**를 보낸다.
	- cipher suit란?![[Pasted image 20240618174309.png]]
		- 이게 어떤 프로토콜이고, 키 교환 방식이 어떻게 되고, 인증서 검증은 어떻게 하면, 대칭키 블록 암호화 방식, 블록 암호 운용방식, 메시지 인증 방식들을 기술한 일종의 메타 데이터라고 생각하면 된다.
	- client hello의 패킷 모양 ![[Pasted image 20240618174544.png]]
---
2. **server hello:** client hello 패킷에서 Cipher suite 중 하나를 선택하여 Client에게 알리는 패킷.
	- 어떤 Cipher suite를 쓸지 보내면서 자신의 SSL 버전, 또 서버에서 만든 **random byte**도 보낸다.
	- server hello 패킷의 모양 ![[Snipaste_2024-06-18_17-47-43.png]]
---
3. **Certificate:** 서버가 자기가 가진 SSL 인증서를 클라이언트에게 넘긴다.
	- 인증서 안에는 서버의 공개 키가 들어있다.
	- 인증서는 CA의 개인키로 암호화 되어있다. CA의 개인키는 남들한테 공개가 안 되어있음.
	- 클라이언트는 세상에 공개되어있는 CA 사의 공개 키로 이걸 복호화 시도한다.
	- 인증서가 복호화 된다면 제대로된 개인 키로 암호화된 것이 맞으니, 실제 인증 문서가 맞다.
---
4. **Server Hello Done**: 복호화된 인증서 내에서 서버의 공개 키를 확보한다.
	- 이후 이 공개 키를 이용하여 클라이언트의 
---
5. **Server Key Exchange**: 서버의 공개 키가 SSL에 없다면, 공개 키를 달라고 서버에 요청한다. 그게 `Server Key Exchange` 이다.
---
6. **Client Key Exchange**: 대칭 키를 서버의 공개 키로 암호화하여 보낸다.
	- 앞으로 https 프로토콜을 쓰며 보낼 데이터들을 암호화하기 위한 대칭 키를 클라이언트가 생성한다.
	- 이 대칭 키를 클라이언트가 서버에서 얻은 공개 키를 이용하여 암호화!
	- 이걸 이제 서버로 보낸다.
---
7. **ChangeCipherSpec**: 클라이언트, 서버 모두가 서로한테 보내는 패킷. 핸드쉐이크를 끝내고 통신할 준비가 되었다는 의미다.
---
8. **Finished**: SSL Handshake를 찐 종료했다는 의미의 패킷.
---
9. **찐 통신 !** -> 여기서부터 진짜로 하고 싶은 통신을 한다. 서비스 이용과 관련된 부분.


## 추가
- CA와 클라이언트 사이에서 이게 CA가 발급해준 인증서라는 걸 검증하는 프로세스가 있어야한다.
- x